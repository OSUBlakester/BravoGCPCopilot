<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tap Interface - Bravo AAC</title>
    
    <!-- Authentication handled via session storage (set by auth.html) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="/static/mood-selection.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100vh;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #94a3b8; /* Darker slate background for contrast */
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #app-container {
            width: 100%;
            max-width: 1200px;
            height: calc(100vh - 40px);
            background-color: #ffffff;
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* --- Admin Toolbar Styles --- */
        .admin-toolbar {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Custom icon size - 20% larger than previous (21.6px) */
        .h-5\.4 {
            height: 1.35rem;
        }
        .w-5\.4 {
            width: 1.35rem;
        }

        /* --- Page Banner Styles --- */
        .page-banner {
            background-color: #002244;
            color: #FB4F14;
            padding: 0.375em 0.75em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .page-banner h1 {
            margin: 0;
            font-size: 1.25em;
            font-weight: 600;
            text-align: left;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 10px;
            gap: 10px;
            overflow: hidden;
        }

        /* Removed top-bar styles as we removed the top bar */

        .clear-btn {
            background: #ff6b6b;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .clear-btn:hover {
            background: #ff5252;
        }

        /* Speech History Section */
        .speech-history-container {
            margin: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .speech-history-container label {
            font-weight: 600;
            color: #333;
            font-size: 0.75em;
            margin-left: 2px;
        }

        .speech-history-row {
            display: flex;
            gap: 5px;
            align-items: stretch;
        }

        .build-space-textarea {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.8em;
            resize: none;
            background-color: #f9f9f9;
            transition: border-color 0.3s ease;
            min-height: 36px;
        }

        .build-space-textarea:focus {
            outline: none;
            border-color: #4CAF50;
            background-color: white;
        }

        .control-buttons {
            display: flex;
            gap: 4px;
            align-items: stretch;
        }

        .control-btn {
            padding: 8px 20px;
            font-size: 0.9rem;
            font-weight: 600;
            border: 1px solid #002244;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            min-height: 36px;
        }

        .speak-btn {
            background-color: #10B981;
            color: white;
            border-color: #10B981;
        }

        .speak-btn:hover {
            background-color: #059669;
            border-color: #059669;
        }

        .backspace-btn {
            background-color: #f59e0b;
            color: white;
            border-color: #f59e0b;
        }

        .backspace-btn:hover {
            background-color: #d97706;
            border-color: #d97706;
        }

        .clear-build-btn {
            background-color: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
        }

        .clear-build-btn:hover {
            background-color: #ff5252;
            border-color: #ff5252;
        }

        /* Modal styles for category navigation */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000; /* High z-index to ensure visibility over splash screen */
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
            padding-bottom: 15px;
        }

        .modal-title {
            font-size: 1.5em;
            font-weight: 600;
            color: #333;
        }

        .modal-close {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2em;
        }

        .modal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .modal-option {
            background: rgba(102, 126, 234, 0.1);
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .modal-option:hover {
            background: rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .main-grid {
            flex: 1;
            display: grid;
            grid-template-columns: 1.5fr 9fr; /* Increased Categories column by 20% */
            gap: 10px;
            min-height: 0;
            height: 100%;
        }

        .categories-column {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Increased gap for better spacing */
            grid-row: 1 / -1;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 100%;
            padding: 15px; /* Increased padding */
            padding-bottom: 100px; /* Increased buffer for scrolling */
            background-color: #cbd5e1; /* Darker gray background to separate from others */
            border-radius: 12px; /* Rounded corners */
        }

        .category-button {
            flex: 0 0 auto; /* Fixed size, don't grow/shrink */
            height: 110px; /* Match Phrases and Words buttons */
            width: 100%;
            
            background: linear-gradient(145deg, #ffffff, #f0f0f0); /* Light button face */
            border: 1px solid rgba(255, 255, 255, 0.6);
            border-radius: 16px; /* Match others */
            
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            
            /* Dynamic shading: Deep drop shadow + crisp inset highlight + subtle bottom bevel */
            box-shadow: 
                0 6px 12px -2px rgba(50, 50, 93, 0.15), 
                0 3px 7px -3px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 1),
                inset 0 -2px 0 rgba(0, 0, 0, 0.05);
                
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0; /* Remove padding to allow image to fill */
            position: relative;
            overflow: hidden;
            margin-bottom: 5px; /* Explicit margin to ensure separation */
        }

        .category-button:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 20px -5px rgba(50, 50, 93, 0.2), 
                0 8px 12px -6px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 1);
        }

        .category-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: scale(1.02);
        }

        /* Sight Word Styling - distinctive format for sight words */
        .sight-word-button {
            font-size: 1.65em !important;
            font-weight: 900 !important;
            color: #dc2626 !important;
        }

        .options-grid-container {
            display: flex;
            flex-direction: column;
            gap: 0px;
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
            scrollbar-width: thin;
            scrollbar-color: #ccc #f0f0f0;
            height: 100%;
            padding-bottom: 150px; /* Increased buffer for scrolling */
        }

        .llm-static-options {
            display: grid;
            /* Grid columns and rows will be set dynamically via JS */
            gap: 8px;
            width: 100%;
            margin: 0;
            padding: 0;
        }

        .freestyle-options {
            display: grid;
            /* Grid columns will be set dynamically via JS */
            grid-template-rows: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-y: auto; /* Allow scrolling if needed */
        }

        /* Section Headers */
        .section-header {
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 8px;
            margin: 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .section-header h3 {
            margin: 0;
            font-size: 0.88em;
            color: #333;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            white-space: nowrap;
        }

        .section-header i {
            margin-right: 6.4px;
            color: #667eea;
        }

        /* Section Containers */
        .phrases-section, .words-section {
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
        }

        .phrases-section {
            flex: 0 0 auto; /* Don't grow, just take needed space */
            margin-bottom: 0;
            transition: all 0.3s ease; /* Smooth transition when resizing */
        }

        .words-section {
            flex: 1; /* Fill remaining space */
            margin-top: 0;
            overflow: hidden; /* Ensure content doesn't overflow container */
        }

        .llm-static-options {
            display: grid;
            /* Grid columns and rows will be set dynamically via JS */
            grid-auto-rows: 110px; /* Fixed height to match Freestyle section */
            gap: 16px; /* Match gap of Freestyle section */
            width: 100%;
            margin: 0;
            padding: 12px; /* Match padding of Freestyle section */
            /* Removed min-height to prevent empty rows */
        }

        .freestyle-options {
            display: grid;
            /* Grid columns will be set dynamically via JS */
            grid-auto-rows: 110px; /* Fixed height */
            gap: 16px; /* Increased gap to prevent touching */
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 12px; /* Increased padding */
            overflow-y: auto;
        }

        .option-button {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            font-size: var(--tap-button-font-size, 0.675em);
            font-weight: 600;
            color: #1a1a1a;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            
            /* Dynamic shading: Deep drop shadow + crisp inset highlight + subtle bottom bevel */
            box-shadow: 
                0 6px 12px -2px rgba(50, 50, 93, 0.15), 
                0 3px 7px -3px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 1),
                inset 0 -2px 0 rgba(0, 0, 0, 0.05);

            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0;
            position: relative;
            overflow: hidden;
            min-height: 45px;
            height: 100%; /* Ensure button fills the grid cell */
        }

        .option-button:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 20px -5px rgba(50, 50, 93, 0.2), 
                0 8px 12px -6px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 1);
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
        }

        .option-button:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        .option-button img {
            width: 9px;
            height: 9px;
            margin-bottom: 2px;
            border-radius: 3px;
        }

        .freestyle-button {
            background: linear-gradient(145deg, #fffbf0, #fff5e0);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: #5c4000;
            font-weight: 600;
        }

        .freestyle-button:hover {
            background: linear-gradient(145deg, #fffbf0, #ffecc0);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin-top: -8px;
            margin-left: -8px;
            border: 2px solid #ccc;
            border-top: 2px solid #666;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Status Message */
        .status-message {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 15px;
            border-radius: 15px;
            font-size: 14px;
            border: 1px solid #ccc;
            z-index: 1000;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Options Grid Container - Full Height */
        .options-grid-container {
            height: 100%;
            overflow-y: auto;
            padding: 10px;
            background-color: #e5e7eb; /* Darker gray background for better contrast */
            border-radius: 12px; /* Rounded corners for the container */
            scrollbar-width: thin;
            scrollbar-color: #ccc #f0f0f0;
        }

        .options-grid-container::-webkit-scrollbar {
            width: 6px;
        }

        .options-grid-container::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 3px;
        }

        .options-grid-container::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .options-grid-container::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        .options-grid-container::-webkit-scrollbar {
            width: 6px;
        }

        .options-grid-container::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 3px;
        }

        .options-grid-container::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        /* Listening highlight for wake word functionality */
        .highlight-listening {
            background-color: #e8f5e8 !important;
            border-color: #4CAF50 !important;
            animation: pulse-listening 1.5s infinite;
        }

        @keyframes pulse-listening {
            0% { border-color: #4CAF50; }
            50% { border-color: #8BC34A; }
            100% { border-color: #4CAF50; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-style: italic;
            background: rgba(255, 255, 255, 0.5);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 5px;
                gap: 5px;
            }
            
            .main-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .categories-column {
                flex-direction: row;
                grid-row: 1;
                overflow-x: auto;
            }
            
            .category-button {
                min-width: 120px;
                padding: 10px;
            }
            
            .options-grid-container {
                grid-column: 1;
                grid-row: 2;
            }
            
            .llm-static-options,
            .freestyle-options {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        /* Tailwind CSS utility classes for admin toolbar */
        .h-8 { height: 2rem; }
        .w-8 { width: 2rem; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .text-gray-600 { color: #4b5563; }
        .bg-gray-100 { background-color: #f3f4f6; }
        .rounded-full { border-radius: 9999px; }
        .transition-colors { transition-property: color, background-color, border-color, fill, stroke; }
        .duration-200 { transition-duration: 200ms; }
        .text-sm { font-size: 0.875rem; }
        .hover\\:bg-blue-100:hover { background-color: #dbeafe; }
        .hover\\:text-blue-600:hover { color: #2563eb; }
        .hover\\:bg-red-100:hover { background-color: #fee2e2; }
        .hover\\:text-red-600:hover { color: #dc2626; }
        .hover\\:bg-green-100:hover { background-color: #dcfce7; }
        .hover\\:text-green-600:hover { color: #16a34a; }
        .border-l { border-left-width: 1px; }
        .border-gray-300 { border-color: #d1d5db; }
        .h-6 { height: 1.5rem; }
        .mx-1 { margin-left: 0.25rem; margin-right: 0.25rem; }
        .ml-2 { margin-left: 0.5rem; }
        .focus\\:outline-none:focus { outline: none; }
        .focus\\:ring-2:focus { box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5); }
        .focus\\:ring-green-500:focus { box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.5); }
        .hidden { display: none; }
        .fixed { position: fixed; }
        .inset-0 { top: 0; right: 0; bottom: 0; left: 0; }
        .bg-black { background-color: #000; }
        .bg-opacity-50 { background-color: rgba(0, 0, 0, 0.5); }
        .z-50 { z-index: 50; }
        .bg-white { background-color: #fff; }
        .p-6 { padding: 1.5rem; }
        .rounded-lg { border-radius: 0.5rem; }
        .shadow-xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }
        .max-w-sm { max-width: 24rem; }
        .w-full { width: 100%; }
        .mx-4 { margin-left: 1rem; margin-right: 1rem; }
        .text-lg { font-size: 1.125rem; }
        .font-semibold { font-weight: 600; }
        .text-gray-800 { color: #1f2937; }
        .mb-4 { margin-bottom: 1rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .border { border-width: 1px; }
        .border-gray-300 { border-color: #d1d5db; }
        .rounded-md { border-radius: 0.375rem; }
        .focus\\:ring-blue-500:focus { box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5); }
        .focus\\:border-blue-500:focus { border-color: #3b82f6; }
        .justify-end { justify-content: flex-end; }
        .space-x-3 > * + * { margin-left: 0.75rem; }
        .mt-4 { margin-top: 1rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .bg-gray-200 { background-color: #e5e7eb; }
        .hover\\:bg-gray-300:hover { background-color: #d1d5db; }
        .focus\\:ring-gray-500:focus { box-shadow: 0 0 0 2px rgba(107, 114, 128, 0.5); }
        .text-white { color: #fff; }
        .bg-blue-600 { background-color: #2563eb; }
        .hover\\:bg-blue-700:hover { background-color: #1d4ed8; }
        .text-red-500 { color: #ef4444; }
        .mt-2 { margin-top: 0.5rem; }
        /* --- Spelling Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            margin: 20px;
            width: 800px;
        }

        /* Specific width for Spelling Modal (40% wider) */
        #spelling-modal .modal-content {
            width: 1120px;
            max-width: 95vw;
            padding: 0;
            overflow: hidden;
        }

        .spell-modal-banner {
            background-color: #002244;
            color: #FB4F14;
            padding: 0.75em 1.5em;
            margin: 0;
            width: 100%;
        }

        .spell-modal-banner h3 {
            margin: 0;
            font-size: 1.25em;
            font-weight: 600;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid #E5E7EB;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
            color: #002244;
        }

        /* Spell modal uses banner instead of modal-header */
        #spelling-modal .modal-header {
            padding: 0;
            border: none;
        }

        .spelling-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            background-color: #e5e7eb;
        }

        .spell-section {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .spell-section-header {
            margin: 0 0 12px 0;
            font-size: 1.0em;
            color: #002244;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .spell-section-header i {
            color: #667eea;
        }

        .current-word-section {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
        }

        .current-word-section label {
            font-size: 1.0rem;
            font-weight: 600;
            color: #374151;
            margin: 0;
            white-space: nowrap;
        }

        .current-word-input {
            flex: 0 1 200px;
            padding: 6px 8px;
            border: 2px solid #002244;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            background-color: #F9FAFB;
            color: #002244;
            text-align: center;
            box-sizing: border-box;
        }

        .word-controls {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
            flex: 1;
        }

        .word-control-btn {
            position: relative;
            padding: 6px 12px;
            font-size: 0.8rem;
            font-weight: 500;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .word-control-btn::before,
        .word-control-btn::after {
            content: "";
            width: 0px;
            height: 0px;
            position: absolute;
            border-right: 6px solid transparent;
            border-bottom: 6px solid transparent;
        }

        .word-control-btn::before {
            border-left: 6px solid currentColor;
            border-top: 6px solid currentColor;
            left: 10px;
            bottom: -12px;
        }

        .word-control-btn::after {
            border-left: 6px solid currentColor;
            border-top: 6px solid currentColor;
            left: 12px;
            bottom: -10px;
            z-index: 1;
        }

        .add-btn {
            background-color: #10B981;
            color: white;
            border-color: #10B981;
        }

        .add-btn:hover {
            background-color: #059669;
        }

        .add-btn::after {
            border-left-color: #10B981;
            border-top-color: #10B981;
        }

        .clear-btn {
            background-color: #EF4444;
            color: white;
            border-color: #EF4444;
        }

        .clear-btn:hover {
            background-color: #DC2626;
        }

        .clear-btn::after {
            border-left-color: #EF4444;
            border-top-color: #EF4444;
        }

        .backspace-btn {
            background-color: #F59E0B;
            color: white;
            border-color: #F59E0B;
        }

        .backspace-btn:hover {
            background-color: #D97706;
        }

        .backspace-btn::after {
            border-left-color: #F59E0B;
            border-top-color: #F59E0B;
        }

        .close-btn {
            background-color: #6B7280;
            color: white;
            border-color: #6B7280;
        }

        .close-btn:hover {
            background-color: #4B5563;
        }

        .close-btn::after {
            border-left-color: #6B7280;
            border-top-color: #6B7280;
        }

        .alphabet-section {
            margin-bottom: 24px;
        }

        .alphabet-section h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }

        .alphabet-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            margin-bottom: 20px;
            padding-bottom: 10px;
        }

        .letter-btn {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(255, 255, 255, 0.6);
            border-radius: 12px;
            font-size: 2.8em;
            font-weight: 700;
            color: #1a1a1a;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            
            /* Match option-button shadow style */
            box-shadow: 
                0 6px 12px -2px rgba(50, 50, 93, 0.15), 
                0 3px 7px -3px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 1),
                inset 0 -2px 0 rgba(0, 0, 0, 0.05);
            
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0;
            min-height: 65px;
            height: 100%;
            position: relative;
        }

        .letter-btn:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 20px -5px rgba(50, 50, 93, 0.2), 
                0 8px 12px -6px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 1);
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
        }

        .letter-btn:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }

        .letter-btn.disabled-letter,
        .letter-btn[disabled] {
            opacity: 0.3;
            background-color: #f3f4f6;
            color: #9ca3af;
            border-color: #d1d5db;
            cursor: not-allowed;
            pointer-events: none;
        }

        .letter-btn.disabled-letter::before {
            border-left-color: #d1d5db;
            border-top-color: #d1d5db;
        }

        .letter-btn.disabled-letter::after {
            border-left-color: #f3f4f6;
            border-top-color: #f3f4f6;
        }

        .predictions-section h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }

        .word-predictions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 4px;
            margin-bottom: 15px;
            padding-bottom: 5px;
        }

        .prediction-btn {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border: 1px solid rgba(255, 255, 255, 0.6);
            border-radius: 12px;
            font-size: 0.9em;
            font-weight: 600;
            color: #1a1a1a;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 
                0 6px 12px -2px rgba(50, 50, 93, 0.15), 
                0 3px 7px -3px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 1),
                inset 0 -2px 0 rgba(0, 0, 0, 0.05);
            padding: 8px 12px;
            text-align: center;
            min-height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .prediction-btn:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 12px 20px -5px rgba(50, 50, 93, 0.2), 
                0 8px 12px -6px rgba(0, 0, 0, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 1);
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
        }

        .prediction-btn:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body>

    <div id="app-container">
    <div class="page-banner">
        <h1 id="dynamic-page-title"><i class="fas fa-hand-pointer"></i> Tap Interface</h1>
        <div class="admin-toolbar">
            <button id="lock-icon" title="Admin Toolbar" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600">
                <i class="fas fa-lock text-xs"></i>
            </button>
            <button id="lock-toolbar-button" title="Lock Admin Toolbar" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-red-100 hover:text-red-600 hidden"><i class="fas fa-lock text-xs"></i></button>
            <a href="tap_interface_admin.html" title="Tap Interface Admin" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-hand-pointer text-xs"></i></a>
            <a href="admin_settings.html" title="Global Settings" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-cog text-xs"></i></a>
            <a href="user_current_admin.html" title="User Current Location" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-map-marker-alt text-xs"></i></a>
            <a href="user_info_admin.html" title="User Info & Birthdays" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-info-circle text-xs"></i></a>
            <a href="user_diary_admin.html" title="User Diary" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-book-open text-xs"></i></a>
            <a href="audio_admin.html" title="Audio Devices" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-volume-up text-xs"></i></a>
            <a href="favorites_admin.html" title="Favorites Topics" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-star text-xs"></i></a>
            <a href="admin_audit_report.html" title="Activity Reports" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-clipboard-list text-xs"></i></a>
            <span class="border-l border-gray-300 h-3 mx-0.5 admin-icon hidden"></span>
            <button id="switch-user-button" title="Switch User Profile" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-users text-xs"></i></button>
            <button id="logout-button" title="Logout" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full transition-colors duration-200 text-xs hover:bg-blue-100 hover:text-blue-600 admin-icon hidden"><i class="fas fa-sign-out-alt text-xs"></i></button>
            <button id="help-icon" title="Help" aria-label="Help" class="h-5.4 w-5.4 flex items-center justify-center text-gray-600 bg-gray-100 rounded-full ml-1 transition-colors duration-200 text-xs hover:bg-green-100 hover:text-green-600 focus:outline-none focus:ring-2 focus:ring-green-500">
                <i class="fas fa-question-circle text-xs"></i>
            </button>
        </div>
    </div>

    <!-- PIN Modal -->
    <div id="pin-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full mx-4">
            <h3 class="text-lg font-semibold text-gray-800 mb-4">Enter Admin PIN</h3>
            <input type="text" id="pin-input" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500" placeholder="Enter PIN" maxlength="10">
            <div class="flex justify-end space-x-3 mt-4">
                <button id="pin-cancel" class="px-4 py-2 text-gray-600 bg-gray-200 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500">Cancel</button>
                <button id="pin-submit" class="px-4 py-2 text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">Submit</button>
            </div>
            <p id="pin-error" class="text-red-500 text-sm mt-2 hidden">Incorrect PIN. Please try again.</p>
        </div>
    </div>

    <!-- Main Application -->
    <div class="container" id="mainApp">
        <!-- Speech History Section -->
        <div class="speech-history-container">
            <label for="build-space">Speech History:</label>
            <div class="speech-history-row">
                <textarea id="build-space" class="build-space-textarea" rows="1" placeholder="Your speech will appear here as you select options..."></textarea>
                <div class="control-buttons">
                    <button id="speak-build-btn" class="control-btn speak-btn">
                        <i class="fas fa-volume-up" style="font-size: 1.1em;"></i> Speak
                    </button>
                    <button id="backspace-build-btn" class="control-btn backspace-btn">
                        <i class="fas fa-backspace" style="font-size: 1.1em;"></i> Backspace
                    </button>
                    <button id="clear-build-btn" class="control-btn clear-build-btn">
                        <i class="fas fa-trash" style="font-size: 1.1em;"></i> Clear
                    </button>
                </div>
            </div>
        </div>

        <div id="question-container" style="margin: 0 10px 10px 10px;">
            <label for="question-display" style="font-weight: 600; color: #333; font-size: 0.75em; margin-left: 2px;">Question:</label>
            <textarea id="question-display" readonly rows="1" style="width: 100%; box-sizing: border-box; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 0.8em; resize: none; background-color: #f9f9f9; min-height: 36px; display: block; margin-top: 4px;"></textarea>
        </div>



        <!-- Category Navigation Modal -->
        <div id="categoryModal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="modalTitle" class="modal-title">Select Option</h2>
                    <button id="modalClose" class="modal-close">&times;</button>
                </div>
                <div id="modalGrid" class="modal-grid">
                    <!-- Options will be populated here -->
                </div>
            </div>
        </div>

        <!-- Main Grid Layout -->
        <div class="main-grid">
            <!-- Categories Column -->
            <div class="categories-column" id="categoriesColumn">
                <div class="section-header">
                    <h3><i class="fas fa-folder-open"></i> Categories</h3>
                </div>
                <div class="categories-content">
                    <!-- Categories will be loaded dynamically -->
                </div>
            </div>

            <!-- Options Grid Container -->
            <div class="options-grid-container">
                <!-- Phrases Section (Top 2 rows) -->
                <div class="phrases-section">
                    <div class="section-header">
                        <h3><i class="fas fa-comment"></i> Quick Talk</h3>
                    </div>
                    <div class="llm-static-options" id="llmStaticOptions">
                        <!-- Generated phrases will appear here -->
                    </div>
                </div>

                <!-- Words Section (Bottom 3 rows) -->
                <div class="words-section">
                    <div class="section-header">
                        <h3><i class="fas fa-font"></i> Free Style</h3>
                    </div>
                    <div class="freestyle-options" id="freestyleOptions">
                        <!-- Word options will appear here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Status Message -->
        <div id="statusMessage" class="status-message">Ready</div>
    </div>
    </div> <!-- End of app-container -->

    <!-- Sight Word Service -->
    <script src="/static/sight-word-service.js"></script>

    <script>
        // Authentication variables (same pattern as gridpage)
        let currentAacUserId = null;
        let firebaseIdToken = null;
        const AAC_USER_ID_SESSION_KEY = "currentAacUserId";
        const FIREBASE_TOKEN_SESSION_KEY = "firebaseIdToken";
        const SELECTED_DISPLAY_NAME_SESSION_KEY = "selectedDisplayName";

        // Global state
        let tapConfig = null;
        let speechQueue = [];
        let currentCategory = null;
        let currentQuestion = null;
        let currentWordsPrompt = null; // Track current words prompt for sentence building
        let currentInstructionPrompt = null; // Track current instruction prompt (LLMQuery) for word generation
        let currentPhrasePrompt = null; // Track current phrase prompt for regeneration
        let currentPhraseContext = null; // Track current phrase context (category/subcategory)
        let currentPhraseOptions = []; // Track current phrase options for exclusion
        let currentWordOptions = []; // Track current word options for exclusion

        // Wake Word Variables (from gridpage)
        let wakeWordInterjection = "hey";
        let wakeWordName = "friend";  // Default should match gridpage
        let LLMOptions = 10; // Default number of phrase options to generate
        let FreestyleWordOptions = 15; // Default number of word options to generate  
        let gridColumns = 10; // Default number of grid columns for button sizing
        let spellLetterOrder = 'alphabetical'; // Default spell letter order (alphabetical, qwerty, or frequency)
        let autoClean = false; // Auto Clean setting for automatic cleanup before speaking
        const QUESTION_TEXTAREA_ID = 'question-display';
        const LISTENING_HIGHLIGHT_CLASS = 'highlight-listening';

        // User Settings (loaded from server)
        let SummaryOff = false; // Default summary state
        let enablePictograms = true; // Always enabled for Tap Interface
        let currentTtsVoiceName = 'en-US-Neural2-A'; // Default voice
        let currentSpeechRate = 180; // Default words-per-minute

        // Note: Using Firestore image lookup instead of emoji pictograms

        // Speech Recognition Variables
        let recognition = null;
        let questionRecognitionInstance = null;
        let isSettingUpRecognition = false;
        let listeningForQuestion = false;

        // Announcement Queue System (from gridpage)
        let announcementQueue = [];
        let isAnnouncingNow = false;
        let speechSynthesisEnabled = false;
        let audioContextInitialized = false;

        // DOM Elements
        const authOverlay = document.getElementById('authOverlay');
        const mainApp = document.getElementById('mainApp');
        const loginBtn = document.getElementById('loginBtn');
        const categoriesColumn = document.getElementById('categoriesColumn');
        const categoriesContent = document.querySelector('.categories-content');
        const llmStaticOptions = document.getElementById('llmStaticOptions');
        const freestyleOptions = document.getElementById('freestyleOptions');
        const buildSpace = document.getElementById('build-space');
        const speakBuildBtn = document.getElementById('speak-build-btn');
        const backspaceBuildBtn = document.getElementById('backspace-build-btn');
        const clearBuildBtn = document.getElementById('clear-build-btn');
        const categoryModal = document.getElementById('categoryModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalGrid = document.getElementById('modalGrid');
        const modalClose = document.getElementById('modalClose');
        const questionDisplay = document.getElementById('question-display');
        const statusMessage = document.getElementById('statusMessage');

        // Status message helper function
        function updateStatusMessage(message) {
            const statusMessageElement = document.getElementById('statusMessage');
            if (statusMessageElement) {
                statusMessageElement.textContent = message;
            }
        }

        // Initialize page when DOM is loaded
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Tap Interface initializing...');
            
            const userReady = await initializeUserContext();
            if (!userReady) {
                // Redirection already handled by initializeUserContext
                return;
            }
            
            initializeTapInterface();
        });

        /**
         * Fetches symbol image from the AAC symbol database (like gridpage)
         * @param {string} text - The button text to find a symbol for
         * @param {Array<string>} keywords - Optional semantic keywords for LLM-generated content  
         * @returns {Promise<string|null>} - Promise that resolves to image URL or null if none found
         */
        async function getSymbolImageForText(text, keywords = null) {
            console.log(`ðŸ” getSymbolImageForText called for "${text}", enablePictograms: ${enablePictograms}`);
            if (!text || text.trim() === '') {
                console.log(`âŒ Empty text provided to getSymbolImageForText`);
                return null;
            }
            
            // Check if this text is a sight word - if so, force text-only display (no images)
            if (window.isSightWord && window.isSightWord(text)) {
                console.log(`ðŸ”¤ Tap interface sight word detected: "${text}" - using text-only display`);
                return null;
            }
            
            // Load images even if enablePictograms is false for debugging
            // if (!enablePictograms) {
            //     console.log(`âŒ Pictograms disabled, skipping image load for "${text}"`);
            //     return null;
            // }
            
            // Simple in-memory cache to avoid repeated requests
            if (!window.symbolImageCache) {
                window.symbolImageCache = new Map();
            }
            
            const cacheKey = `tap_${text.trim().toLowerCase()}`;
            if (window.symbolImageCache.has(cacheKey)) {
                const cached = window.symbolImageCache.get(cacheKey);
                if (cached.timestamp > Date.now() - 300000) { // Cache for 5 minutes
                    return cached.imageUrl;
                }
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.warn(`â° Timeout reached for symbol search: "${text}"`);
                    controller.abort();
                }, 10000); // Increased to 10 second timeout
                
                // Use unified button-search that searches Firestore collections with keywords support
                let symbolsUrl = `/api/symbols/button-search?q=${encodeURIComponent(text.trim())}&limit=1`;
                if (keywords && keywords.length > 0) {
                    symbolsUrl += `&keywords=${encodeURIComponent(JSON.stringify(keywords))}`;
                }
                
                const response = await authenticatedFetch(symbolsUrl, {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    console.warn(`Symbol search failed for "${text}": ${response.status}`);
                    return null;
                }
                
                const data = await response.json();
                
                if (data && data.symbols && Array.isArray(data.symbols) && data.symbols.length > 0) {
                    const symbolUrl = data.symbols[0].url;
                    // Cache the result
                    window.symbolImageCache.set(cacheKey, {
                        imageUrl: symbolUrl,
                        timestamp: Date.now()
                    });
                    console.log(`âœ… Found Firestore image for "${text}": ${symbolUrl}`);
                    return symbolUrl;
                } else {
                    // Cache null result to avoid repeated failed requests
                    window.symbolImageCache.set(cacheKey, {
                        imageUrl: null,
                        timestamp: Date.now()
                    });
                    console.log(`âŒ No Firestore image found for "${text}"`);
                    return null;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.warn(`ðŸš« Request aborted for symbol "${text}" - likely due to timeout`);
                } else {
                    console.error(`Error fetching symbol for "${text}":`, error);
                }
                return null;
            }
        }

        // Load user settings from server (like gridpage loadScanSettings)
        async function loadUserSettings() {
            try {
                console.log('Loading user settings...');
                const response = await authenticatedFetch('/api/settings', {
                    method: 'GET'
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`HTTP error loading settings! status: ${response.status} ${errorText}`);
                    return;
                }

                const settings = await response.json();
                console.log('Loaded settings:', settings);
                
                // Load Summary setting
                // FORCE SummaryOff to false for Tap Interface to ensure buttons are readable
                // The user prefers summaries on this interface regardless of global setting
                SummaryOff = false; 
                console.log('SummaryOff setting (FORCED FALSE for Tap):', SummaryOff);
                
                // Load Pictogram setting
                // enablePictograms = settings.enablePictograms === true;
                // console.log('enablePictograms setting:', enablePictograms, 'Raw value:', settings.enablePictograms);
                
                // Force enable for Tap Interface
                console.log('ðŸ”§ DEBUG: Forcing enablePictograms to true for Tap Interface');
                enablePictograms = true;
                
                // Load TTS settings
                if (settings && typeof settings.speech_rate === 'number' && !isNaN(settings.speech_rate)) {
                    currentSpeechRate = parseInt(settings.speech_rate);
                    console.log(`Speech Rate loaded: ${currentSpeechRate} WPM`);
                }
                
                if (settings && typeof settings.selected_tts_voice_name === 'string' && settings.selected_tts_voice_name.trim()) {
                    currentTtsVoiceName = settings.selected_tts_voice_name;
                    console.log(`TTS Voice Name loaded: "${currentTtsVoiceName}"`);
                }
                
                // Load Wake Word parts
                if (settings && typeof settings.wakeWordInterjection === 'string' && settings.wakeWordInterjection.trim()) {
                    wakeWordInterjection = settings.wakeWordInterjection.trim().toLowerCase();
                    console.log(`Wake Word Interjection loaded: "${wakeWordInterjection}"`);
                } else {
                    wakeWordInterjection = "hey";
                }
                
                if (settings && typeof settings.wakeWordName === 'string' && settings.wakeWordName.trim()) {
                    wakeWordName = settings.wakeWordName.trim().toLowerCase();
                    console.log(`Wake Word Name loaded: "${wakeWordName}"`);
                } else {
                    wakeWordName = "friend";
                }
                
                // Load LLMOptions
                if (settings && typeof settings.LLMOptions === 'number' && !isNaN(settings.LLMOptions)) {
                    LLMOptions = Math.max(1, parseInt(settings.LLMOptions));
                    console.log(`LLM Options loaded: ${LLMOptions}`);
                } else {
                    LLMOptions = 10;
                }
                
                // Load FreestyleWordOptions
                if (settings && typeof settings.FreestyleOptions === 'number' && !isNaN(settings.FreestyleOptions)) {
                    FreestyleWordOptions = Math.max(1, parseInt(settings.FreestyleOptions));
                    console.log(`Freestyle Word Options loaded: ${FreestyleWordOptions}`);
                } else {
                    FreestyleWordOptions = 15;
                }
                
                // Load gridColumns
                // Load gridColumns
                if (settings && typeof settings.gridColumns === 'number' && !isNaN(settings.gridColumns)) {
                    gridColumns = Math.max(2, Math.min(18, parseInt(settings.gridColumns)));
                    console.log(`Grid Columns loaded: ${gridColumns}`);
                } else {
                    gridColumns = 10; // Default value
                }
                
                // Load spellLetterOrder
                if (settings && typeof settings.spellLetterOrder === 'string') {
                    spellLetterOrder = settings.spellLetterOrder;
                    console.log(`Spell Letter Order loaded: ${spellLetterOrder}`);
                } else {
                    spellLetterOrder = 'alphabetical'; // Default value
                }
                
                // Load Auto Clean setting
                if (settings && typeof settings.autoClean === 'boolean') {
                    autoClean = settings.autoClean;
                    console.log(`Auto Clean loaded: ${autoClean}`);
                } else {
                    autoClean = false; // Default value
                }
                
            } catch (error) {
                console.error('Error loading user settings:', error);
                // Use defaults on error
            }
        }

        // Apply dynamic grid layout based on gridColumns setting (like gridpage)
        function applyGridLayout() {
            const llmStaticOptions = document.getElementById('llmStaticOptions');
            const freestyleOptions = document.getElementById('freestyleOptions');
            
            if (llmStaticOptions && freestyleOptions) {
                // Use full gridColumns for both phrases and words sections (same sizing)
                const phraseColumns = gridColumns;
                const wordColumns = gridColumns;
                
                // Only set columns here. Rows are handled dynamically by renderCategoryOptions (for phrases)
                // and CSS grid-auto-rows (for words) to ensure proper spacing and sizing.
                
                llmStaticOptions.style.gridTemplateColumns = `repeat(${phraseColumns}, 1fr)`;
                // REMOVED: llmStaticOptions.style.gridTemplateRows = ... (Handled by renderCategoryOptions)
                
                freestyleOptions.style.gridTemplateColumns = `repeat(${wordColumns}, 1fr)`;
                // REMOVED: freestyleOptions.style.gridTemplateRows = ... (Handled by CSS)
                
                // Apply dynamic font sizing based on grid density (like gridpage)
                const baseFontSize = 16;
                const minFontSize = 8;
                const maxFontSize = 18;
                const fontSize = Math.max(minFontSize, Math.min(maxFontSize, baseFontSize * (8 / gridColumns)));
                
                document.documentElement.style.setProperty('--tap-button-font-size', `${fontSize}px`);
                
                console.log(`Applied grid layout columns: ${phraseColumns}, Font: ${fontSize}px`);
            }
        }
        
        // Regenerate phrase options using stored context with exclusion
        async function regeneratePhraseOptions() {
            if (!currentPhrasePrompt) {
                console.warn('No current phrase prompt stored for regeneration');
                return;
            }
            
            try {
                console.log('ðŸ”„ Regenerating phrase options with prompt:', currentPhrasePrompt);
                console.log('ðŸ”„ Excluding current options:', currentPhraseOptions);
                
                // Show loading state
                llmStaticOptions.innerHTML = '';
                for (let i = 0; i < LLMOptions; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'option-button loading';
                    btn.textContent = '...';
                    llmStaticOptions.appendChild(btn);
                }
                
                // Create exclusion text from current options
                const excludedOptionsText = currentPhraseOptions
                    .map(opt => (typeof opt === 'object' && opt.option) ? opt.option : opt)
                    .filter(text => typeof text === 'string' && text.trim() !== '')
                    .join('; ');
                
                // Generate new options with exclusion
                const options = await generateGridpageLLMOptionsWithExclusion(currentPhrasePrompt, LLMOptions, excludedOptionsText);
                renderCategoryOptions(options);
                
            } catch (error) {
                console.error('Error regenerating phrase options:', error);
                updateStatusMessage('Error generating new phrases');
            }
        }
        
        // Regenerate word options using stored context with exclusion
        async function regenerateWordOptions() {
            if (!currentCategory) {
                console.warn('No current category stored for regeneration');
                return;
            }
            
            try {
                console.log('ðŸ”„ Regenerating word options for category:', currentCategory.label);
                console.log('ðŸ”„ Excluding current words:', currentWordOptions);
                
                // Show loading state
                freestyleOptions.innerHTML = '';
                for (let i = 0; i < FreestyleWordOptions; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'option-button freestyle-button loading';
                    btn.textContent = '...';
                    freestyleOptions.appendChild(btn);
                }
                
                // Create exclusion text from current word options
                const excludedWords = currentWordOptions
                    .map(opt => (typeof opt === 'object' && opt.text) ? opt.text : opt)
                    .filter(text => typeof text === 'string' && text.trim() !== '');
                
                // Generate new options with exclusion using freestyle logic
                // IMPORTANT: Pass currentInstructionPrompt to ensure custom prompts are respected during regeneration
                const newFreestyleOptions = await generateFreestyleLLMOptionsWithExclusion(currentCategory.label, FreestyleWordOptions, currentInstructionPrompt, excludedWords);
                renderFreestyleOptions(newFreestyleOptions);
                
            } catch (error) {
                console.error('Error regenerating word options:', error);
                updateStatusMessage('Error generating new words');
            }
        }
        
        // Initialize the tap interface page
        async function initializeTapInterface() {
            try {
                console.log('Initializing tap interface...');
                updateStatusMessage('Loading...');
                
                // Setup event listeners for buttons
                setupEventListeners();
                
                // Setup spelling modal
                setupSpellingModal();
                
                // Load user data and configuration
                await initializeUserData();
                
                // Apply dynamic grid layout after settings are loaded
                applyGridLayout();
                
                updateStatusMessage('Ready - Say Hey Bravo to start');
                
                // Render interface
                await renderInterface();
                await loadFreestyleOptions();
                
                // Pre-cache images in BACKGROUND (don't await)
                preCacheCategoryImages();
                
            } catch (error) {
                console.error('Error initializing tap interface:', error);
                updateStatusMessage('Error loading interface');
            }
        }
        
        // Pre-cache images for all categories
        async function preCacheCategoryImages() {
            if (!tapConfig || !tapConfig.buttons) return;
            
            console.log('ðŸš€ Starting image pre-caching...');
            const totalButtons = tapConfig.buttons.length;
            let processed = 0;
            
            // Create a list of all terms to cache (categories + children)
            const termsToCache = [];
            
            tapConfig.buttons.forEach(btn => {
                if (!btn.hidden) {
                    termsToCache.push(btn.label);
                    if (btn.children) {
                        btn.children.forEach(child => {
                            if (!child.hidden) {
                                termsToCache.push(child.label);
                            }
                        });
                    }
                }
            });
            
            console.log(`ðŸš€ Found ${termsToCache.length} terms to pre-cache`);
            
            // Process in batches to avoid overwhelming the browser/network
            const batchSize = 5;
            for (let i = 0; i < termsToCache.length; i += batchSize) {
                const batch = termsToCache.slice(i, i + batchSize);
                await Promise.all(batch.map(term => getSymbolImageForText(term)));
                
                processed += batch.length;
            }
            
            console.log('ðŸš€ Image pre-caching complete');
        }

        // Authenticated fetch function (same pattern as gridpage)
        async function authenticatedFetch(url, options = {}) {
            if (!firebaseIdToken || !currentAacUserId) {
                console.error("Authentication: Firebase ID Token or AAC User ID not found. Redirecting to login.");
                sessionStorage.clear();
                window.location.href = 'auth.html';
                throw new Error("Authentication required.");
            }

            const headers = options.headers || {};
            headers['Authorization'] = `Bearer ${firebaseIdToken}`;
            headers['X-User-ID'] = currentAacUserId;
            
            // Check for admin context and add target account header if needed
            const adminTargetAccountId = sessionStorage.getItem('adminTargetAccountId');
            if (adminTargetAccountId) {
                headers['X-Admin-Target-Account'] = adminTargetAccountId;
            }
            
            options.headers = headers;

            // Add a check for 401/403 responses to trigger re-authentication
            const response = await fetch(url, options);
            if (response.status === 401 || response.status === 403) {
                console.warn(`Authentication failed (${response.status}) for ${url}. Redirecting to login.`);
                sessionStorage.clear();
                window.location.href = 'auth.html';
                throw new Error("Session expired or invalid.");
            }
            return response;
        }

        // Initialize user context (same pattern as gridpage)
        async function initializeUserContext() {
            console.log('initializeUserContext: Starting initialization...');
            
            firebaseIdToken = sessionStorage.getItem(FIREBASE_TOKEN_SESSION_KEY);
            currentAacUserId = sessionStorage.getItem(AAC_USER_ID_SESSION_KEY);

            if (!firebaseIdToken || !currentAacUserId) {
                console.log("No Firebase ID Token or AAC User ID found in session. Redirecting to auth.html.");
                sessionStorage.clear();
                window.location.href = 'auth.html';
                return false;
            }
            
            console.log(`User context initialized. AAC User ID: ${currentAacUserId}`);
            return true;
        }

        function setupEventListeners() {
            // Build space controls
            speakBuildBtn.addEventListener('click', () => {
                enableSpeechSynthesis(); // Enable on first user gesture
                speakBuildSpace();
            });
            backspaceBuildBtn.addEventListener('click', backspaceBuildSpace);
            clearBuildBtn.addEventListener('click', clearBuildSpace);
            
            // Modal controls
            modalClose.addEventListener('click', closeModal);
            categoryModal.addEventListener('click', (e) => {
                if (e.target === categoryModal) closeModal();
            });
            
            // Add click listeners to enable speech synthesis on any user interaction
            document.addEventListener('click', enableSpeechSynthesis, { once: true });
            document.addEventListener('touchstart', enableSpeechSynthesis, { once: true });
        }

        // Generate word options with exclusion (like freestyle page)
        async function generateFreestyleLLMOptionsWithExclusion(category, count, wordsPrompt, excludedWords) {
            const wordsCount = count || FreestyleWordOptions;
            console.log('generateFreestyleLLMOptionsWithExclusion called with category:', category, 'count:', wordsCount, 'wordsPrompt:', wordsPrompt, 'excluding:', excludedWords);
            
            try {
                if (category && category !== 'general') {
                    // Get current mood for context
                    const currentMood = getCurrentMood ? getCurrentMood() : null;
                    
                    // Use category-words endpoint with exclusion
                    const requestBody = {
                        category: category,
                        build_space_content: buildSpace.value || '',
                        count: wordsCount,
                        exclude_words: excludedWords,
                        custom_prompt: wordsPrompt || null, // Use custom_prompt for server priority
                        current_mood: currentMood
                    };
                    
                    console.log('ðŸŸ¡ Sending exclusion request to /api/freestyle/category-words:', requestBody);
                    
                    const response = await authenticatedFetch('/api/freestyle/category-words', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('ðŸŸ¢ Category words exclusion response:', data);
                        return data.words || [];
                    }
                }
                
                // Fallback to general word options with exclusion
                const requestBody = {
                    "speech_history": buildSpace.value || '',
                    "count": wordsCount,
                    "exclude_words": excludedWords
                };
                
                console.log('ðŸŸ¡ Sending exclusion request to /api/freestyle/word-options:', requestBody);
                
                const response = await authenticatedFetch('/api/freestyle/word-options', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('ðŸŸ¢ Word options exclusion response:', data.word_options);
                    return data.word_options || [];
                } else {
                    console.error('ðŸ”´ Word options exclusion API failed:', response.status);
                    return [];
                }
                
            } catch (error) {
                console.error('Error in generateFreestyleLLMOptionsWithExclusion:', error);
                return [];
            }
        }

        async function initializeUserData() {
            try {
                // Load user settings first (like gridpage)
                await loadUserSettings();
                // Load tap interface configuration
                await loadTapConfig();
                // Rendering moved to initializeTapInterface to allow pre-caching
            } catch (error) {
                console.error('Failed to initialize user data:', error);
            }
        }

        async function loadTapConfig() {
            try {
                // Add timestamp to prevent caching
                const response = await authenticatedFetch(`/api/tap-interface/config?t=${Date.now()}`);

                if (response.ok) {
                    tapConfig = await response.json();
                    console.log('Loaded tap config:', tapConfig);
                    // Debug: Check for words_prompt in buttons
                    if (tapConfig.buttons) {
                        tapConfig.buttons.forEach(b => {
                            if (b.words_prompt) console.log(`Button ${b.label} has words_prompt: ${b.words_prompt.substring(0, 20)}...`);
                            if (b.children) {
                                b.children.forEach(c => {
                                    if (c.words_prompt) console.log(`  Child ${c.label} has words_prompt: ${c.words_prompt.substring(0, 20)}...`);
                                    else console.log(`  Child ${c.label} has NO words_prompt`);
                                });
                            }
                        });
                    }
                } else {
                    console.error('Failed to load tap configuration');
                    tapConfig = { buttons: [] };
                }
            } catch (error) {
                console.error('Error loading tap config:', error);
                tapConfig = { buttons: [] };
            }
        }

        async function renderInterface() {
            renderCategories();
            // Load initial generic phrases and freestyle options
            await loadInitialPhrases();
            // Freestyle options are loaded separately in initializeUserData()
        }

        async function loadInitialPhrases() {
            console.log('Loading initial generic phrases...');
            try {
                // Generate generic conversation starters and common phrases
                const genericPrompt = "Generate general conversation starters and common communication phrases for everyday social interactions";
                // Store the prompt for Something Else regeneration
                currentPhrasePrompt = genericPrompt;
                const options = await generateGridpageLLMOptions(genericPrompt, LLMOptions);
                console.log('Generated initial phrases:', options);
                renderCategoryOptions(options);
            } catch (error) {
                console.error('Error loading initial phrases:', error);
                // Show empty state if loading fails
                renderCategoryOptions([]);
            }
        }

        function renderCategories() {
            console.log('Rendering categories, tapConfig:', tapConfig);
            
            if (!categoriesContent) {
                console.error('Categories content container not found');
                return;
            }
            
            categoriesContent.innerHTML = '';
            
            if (!tapConfig || !tapConfig.buttons || tapConfig.buttons.length === 0) {
                console.log('No tap config or buttons found');
                categoriesContent.innerHTML = '<div class="empty-state">No categories configured</div>';
                return;
            }
            
            console.log('Found', tapConfig.buttons.length, 'category buttons');
            
            // Debug: Show which buttons have audio files configured
            tapConfig.buttons.forEach((button, index) => {
                console.log(`[AUDIO DEBUG] Button ${index}: "${button.label}" - Audio: ${button.custom_audio_file ? 'âœ“ ' + button.custom_audio_file : 'âœ— None'}`);
            });

            tapConfig.buttons.forEach(button => {
                // Skip hidden buttons
                if (button.hidden) {
                    return;
                }

                const categoryBtn = document.createElement('button');
                categoryBtn.className = 'category-button';
                
                // Check if this is a sight word - if so, apply special styling and skip images
                const isSightWord = window.isSightWord && window.isSightWord(button.label);
                
                // Only apply custom background if specified in config, otherwise let CSS handle it
                if (button.background_color && button.background_color !== '#FFFFFF') {
                    categoryBtn.style.backgroundColor = button.background_color;
                }
                
                if (!isSightWord) {
                    categoryBtn.style.color = button.text_color || '#000000';
                }
                
                // Add Firestore image support for categories (like gridpage) - skip for sight words
                if (!isSightWord) {
                    console.log(`ðŸ” Attempting image load for category: "${button.label}"`);
                    getSymbolImageForText(button.label).then(imageUrl => {
                        console.log(`ðŸŽ¯ Image result for "${button.label}": ${imageUrl ? 'Found' : 'Not found'}`);
                        if (imageUrl) {
                            // Create image + text layout like gridpage
                            categoryBtn.innerHTML = '';
                            const buttonContent = document.createElement('div');
                            buttonContent.style.position = 'relative';
                            buttonContent.style.width = '100%';
                            buttonContent.style.height = '100%';
                            buttonContent.style.display = 'flex';
                            buttonContent.style.flexDirection = 'column';
                            
                            const imageContainer = document.createElement('div');
                            imageContainer.style.flex = '1';
                            imageContainer.style.width = '100%';
                            imageContainer.style.overflow = 'hidden';
                            imageContainer.style.borderRadius = '8px 8px 0 0';
                            imageContainer.style.display = 'flex';
                            imageContainer.style.alignItems = 'center';
                            imageContainer.style.justifyContent = 'center';
                            
                            const imageElement = document.createElement('img');
                            imageElement.src = imageUrl;
                            imageElement.alt = button.label;
                            imageElement.style.width = '100%';
                            imageElement.style.height = '100%';
                            imageElement.style.objectFit = 'cover';
                            
                            const textFooter = document.createElement('div');
                            textFooter.style.height = '18px';
                            textFooter.style.width = '100%';
                            textFooter.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
                            textFooter.style.color = 'white';
                            textFooter.style.display = 'flex';
                            textFooter.style.alignItems = 'center';
                            textFooter.style.justifyContent = 'center';
                            textFooter.style.padding = '1px 2px';
                            textFooter.style.position = 'absolute';
                            textFooter.style.bottom = '0';
                            textFooter.style.left = '0';
                            textFooter.style.right = '0';
                            
                            const textSpan = document.createElement('span');
                            textSpan.textContent = button.label;
                            textSpan.style.fontSize = '0.7em';
                            textSpan.style.fontWeight = 'bold';
                            textSpan.style.textAlign = 'center';
                            
                            imageContainer.appendChild(imageElement);
                            textFooter.appendChild(textSpan);
                            buttonContent.appendChild(imageContainer);
                            buttonContent.appendChild(textFooter);
                            categoryBtn.appendChild(buttonContent);
                        }
                    }).catch(error => {
                        console.error('Error loading image for category button:', error);
                    });
                }
                
                // Set initial text (will be replaced by image if found)
                // For sight words, apply special styling
                if (isSightWord) {
                    console.log('[SIGHT WORD] Rendering text-only button for:', button.label);
                    categoryBtn.classList.add('sight-word-button');
                    const textSpan = document.createElement('span');
                    textSpan.textContent = button.label;
                    textSpan.style.fontSize = '1.25em';
                    textSpan.style.fontWeight = '900';
                    textSpan.style.color = '#dc2626';
                    categoryBtn.appendChild(textSpan);
                } else {
                    categoryBtn.textContent = button.label;
                }
                
                categoryBtn.addEventListener('click', async (event) => {
                    console.log(`[DEBUG] Button clicked: ${button.label}`);
                    console.log(`[DEBUG] Button data:`, button);
                    console.log(`[DEBUG] Custom audio file:`, button.custom_audio_file);
                    
                    // Only announce if there is a speech_text value
                    if (button.speech_text && button.speech_text.trim() !== '') {
                        await announce(button.speech_text, "system", true);
                    }
                    
                    // Play custom audio file if assigned
                    if (button.custom_audio_file) {
                        console.log(`[DEBUG] Playing custom audio: ${button.custom_audio_file}`);
                        try {
                            await playCustomButtonAudio(button.custom_audio_file);
                        } catch (error) {
                            console.error('Error playing button audio:', error);
                        }
                    } else {
                        console.log(`[DEBUG] No custom audio file configured for button: ${button.label}`);
                    }
                    
                    selectCategory(button, event);
                });
                categoriesContent.appendChild(categoryBtn);
            });
        }

        async function selectCategory(category, event) {
            console.log('Selecting category:', category);
            
            // Check for special function
            if (category.special_function === 'spell') {
                console.log('Opening Spelling Modal');
                openSpellingModal();
                return;
            }
            
            // Update active state
            document.querySelectorAll('.category-button').forEach(btn => {
                btn.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            currentCategory = category;
            
            // If category has children, show modal (pass parent path so nested selection builds full path)
            if (category.children && category.children.length > 0) {
                console.log('Category has', category.children.length, 'children, showing modal');
                console.log('Children:', category.children.map(c => c.label));
                showCategoryModal(category, category.label);
                return;
            }
            
            // Show splash screen for loading options
            showSplashScreen(`Loading ${category.label}...`);
            
            console.log('Loading phrases for category:', category.label);
            
            // Clear existing options
            llmStaticOptions.innerHTML = '';
            
            // Show loading state
            for (let i = 0; i < LLMOptions; i++) {
                const btn = document.createElement('button');
                btn.className = 'option-button loading';
                btn.textContent = '...';
                llmStaticOptions.appendChild(btn);
            }

            try {
                let options = [];
                
                // PHRASES SECTION LOGIC
                if (category.llm_prompt) {
                    console.log('Generating LLM options with prompt:', category.llm_prompt);
                    // Generate full phrases using gridpage-style LLM
                    options = await generateGridpageLLMOptions(category.llm_prompt, LLMOptions);
                    console.log('Generated options:', options);
                } else {
                    // Fallback: Use category label as prompt if no specific prompt is provided
                    console.log('No llm_prompt found, using category label as prompt:', category.label);
                    const fallbackPrompt = `Generate phrases related to ${category.label}`;
                    options = await generateGridpageLLMOptions(fallbackPrompt, LLMOptions);
                }

                console.log('Final options to render:', options);
                renderCategoryOptions(options);
                
                // WORDS SECTION LOGIC
                console.log('Updating freestyle options for category:', category.label || category);
                console.log('Category has words_prompt:', category.words_prompt);
                console.log('Category has llm_prompt:', category.llm_prompt);
                
                // Store the words prompt and instruction prompt globally for word selection
                currentWordsPrompt = category.words_prompt || null;
                currentInstructionPrompt = category.llm_prompt || null;

                if (category.static_options) {
                    console.log('Using static options for Words section:', category.static_options);
                    const staticWords = category.static_options.split(',').map(opt => opt.trim()).filter(opt => opt);
                    // Format as objects for renderFreestyleOptions
                    const wordOptions = staticWords.map(text => ({ text: text, keywords: [] }));
                    renderFreestyleOptions(wordOptions);
                } else {
                    await updateFreestyleOptionsWithContext(category.label || category, true, category.words_prompt, category.llm_prompt);
                }
            } catch (error) {
                console.error('Error loading category options:', error);
                renderCategoryOptions([]);
            }
        }

        // Show modal for a category, providing an optional parentPath for nested categories
        function showCategoryModal(category, parentPath = null) {
            console.log('showCategoryModal called for:', category.label, 'with', category.children.length, 'children');
            console.log('Modal elements - modalTitle:', modalTitle, 'modalGrid:', modalGrid, 'categoryModal:', categoryModal);
            
            if (!categoryModal || !modalTitle || !modalGrid) {
                console.error('Modal elements not found!');
                return;
            }
            
            modalTitle.textContent = category.label;
            modalGrid.innerHTML = '';
            const basePath = parentPath ? parentPath : category.label;

            // Debug: Show which child buttons have audio files configured
            category.children.forEach((child, index) => {
                console.log(`[AUDIO DEBUG] Child Button ${index}: "${child.label}" - Audio: ${child.custom_audio_file ? 'âœ“ ' + child.custom_audio_file : 'âœ— None'}`);
            });

            category.children.forEach(child => {
                // Skip hidden child buttons
                if (child.hidden) {
                    return;
                }

                console.log('Adding child option:', child.label);
                const categoryBtn = document.createElement('button');
                categoryBtn.className = 'modal-option category-button';
                categoryBtn.style.backgroundColor = child.background_color || '#FFFFFF';
                categoryBtn.style.color = child.text_color || '#000000';
                
                // Add image support for child categories (same as main categories)
                console.log(`ðŸ” Attempting image load for child category: "${child.label}"`);
                getSymbolImageForText(child.label).then(imageUrl => {
                    console.log(`ðŸŽ¯ Image result for "${child.label}": ${imageUrl ? 'Found' : 'Not found'}`);
                    if (imageUrl) {
                        // Create image + text layout like main categories
                        categoryBtn.innerHTML = '';
                        const buttonContent = document.createElement('div');
                        buttonContent.style.position = 'relative';
                        buttonContent.style.width = '100%';
                        buttonContent.style.height = '100%';
                        buttonContent.style.display = 'flex';
                        buttonContent.style.flexDirection = 'column';
                        
                        const imageContainer = document.createElement('div');
                        imageContainer.style.flex = '1';
                        imageContainer.style.width = '100%';
                        imageContainer.style.overflow = 'hidden';
                        imageContainer.style.borderRadius = '8px 8px 0 0';
                        imageContainer.style.display = 'flex';
                        imageContainer.style.alignItems = 'center';
                        imageContainer.style.justifyContent = 'center';
                        
                        const imageElement = document.createElement('img');
                        imageElement.src = imageUrl;
                        imageElement.alt = child.label;
                        imageElement.style.width = '100%';
                        imageElement.style.height = '100%';
                        imageElement.style.objectFit = 'cover';
                        
                        const textFooter = document.createElement('div');
                        textFooter.style.height = '18px';
                        textFooter.style.width = '100%';
                        textFooter.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
                        textFooter.style.color = 'white';
                        textFooter.style.display = 'flex';
                        textFooter.style.alignItems = 'center';
                        textFooter.style.justifyContent = 'center';
                        textFooter.style.padding = '1px 2px';
                        textFooter.style.position = 'absolute';
                        textFooter.style.bottom = '0';
                        textFooter.style.left = '0';
                        textFooter.style.right = '0';
                        
                        const textSpan = document.createElement('span');
                        textSpan.textContent = child.label;
                        textSpan.style.fontSize = '0.7em';
                        textSpan.style.fontWeight = 'bold';
                        textSpan.style.textAlign = 'center';
                        
                        imageContainer.appendChild(imageElement);
                        textFooter.appendChild(textSpan);
                        buttonContent.appendChild(imageContainer);
                        buttonContent.appendChild(textFooter);
                        categoryBtn.appendChild(buttonContent);
                    }
                }).catch(error => {
                    console.error('Error loading image for child category button:', error);
                });
                
                // Set initial text (will be replaced by image if found)
                categoryBtn.textContent = child.label;
                
                categoryBtn.addEventListener('click', async () => {
                    console.log(`[DEBUG] Child button clicked: ${child.label}`);
                    console.log(`[DEBUG] Child button data:`, child);
                    console.log(`[DEBUG] Child custom audio file:`, child.custom_audio_file);
                    
                    // Only announce if there is a speech_text value (same logic as main categories)
                    if (child.speech_text && child.speech_text.trim() !== '') {
                        await announce(child.speech_text, "system", true);
                    }
                    
                    // Play custom audio file if assigned (same logic as main categories)
                    if (child.custom_audio_file) {
                        console.log(`[DEBUG] Playing custom audio for child: ${child.custom_audio_file}`);
                        try {
                            await playCustomButtonAudio(child.custom_audio_file);
                        } catch (error) {
                            console.error('Error playing child button audio:', error);
                        }
                    } else {
                        console.log(`[DEBUG] No custom audio file configured for child button: ${child.label}`);
                    }
                    
                    console.log('Subcategory clicked:', child.label);
                    selectSubcategory(child, basePath);
                });
                
                modalGrid.appendChild(categoryBtn);
            });

            categoryModal.style.display = 'flex';
            console.log('Modal should now be visible');
        }

        async function selectSubcategory(subcategory, parentPath = '') {
            // If subcategory has children, show another modal level with updated parent path
            const fullParentPath = parentPath ? `${parentPath}, ${subcategory.label}` : subcategory.label;
            if (subcategory.children && subcategory.children.length > 0) {
                showCategoryModal(subcategory, fullParentPath);
                return;
            }

            // Close modal and load options
            closeModal();
            
            // Show splash screen for loading options
            showSplashScreen(`Loading ${subcategory.label}...`);

            // Clear existing options and show loading
            llmStaticOptions.innerHTML = '';
            for (let i = 0; i < LLMOptions; i++) {
                const btn = document.createElement('button');
                btn.className = 'option-button loading';
                llmStaticOptions.appendChild(btn);
            }

            try {
                let options = [];

                if (subcategory.static_options) {
                    // Use static options - format as structured options with full phrases
                    const staticTexts = subcategory.static_options.split(',').map(opt => opt.trim()).filter(opt => opt);
                    options = staticTexts.map(text => ({
                        option: text,
                        summary: text.length > 20 ? text.substring(0, 17) + '...' : text,
                        keywords: []
                    }));
                    currentPhrasePrompt = null;
                    currentPhraseContext = null;
                } else if (subcategory.llm_prompt) {
                    // Generate full phrases using gridpage-style LLM and store context for regeneration
                    currentPhrasePrompt = subcategory.llm_prompt;
                    currentPhraseContext = subcategory;
                    options = await generateGridpageLLMOptions(subcategory.llm_prompt, LLMOptions);
                }

                renderCategoryOptions(options);

                // Also update freestyle options with the selected category context 
                // IMPORTANT: Use just the subcategory name for API calls, not the full path
                // This ensures "Insects" is sent instead of "Animals, Insects" which matches server expectations
                const categoryForApi = subcategory.label; // Just "Insects", not "Animals, Insects"
                const fullPath = fullParentPath; // Keep full path for display/context
                // Set currentCategory to preserve context for future freestyle calls
                currentCategory = { label: fullPath };
                console.log('Subcategory has words_prompt:', subcategory.words_prompt);
                console.log('Using category for API:', categoryForApi, 'vs full path:', fullPath);
                // Store the words prompt and instruction prompt globally for word selection
                currentWordsPrompt = subcategory.words_prompt || null;
                currentInstructionPrompt = subcategory.llm_prompt || null;
                
                // DEBUG: Log what we are about to send
                console.log(`[DEBUG] Calling updateFreestyleOptionsWithContext with prompt:`, currentWordsPrompt, 'and instruction:', subcategory.llm_prompt);
                
                await updateFreestyleOptionsWithContext(categoryForApi, true, subcategory.words_prompt, subcategory.llm_prompt);
            } catch (error) {
                console.error('Error loading subcategory options:', error);
                renderCategoryOptions([]);
            }
        }

        function closeModal() {
            categoryModal.style.display = 'none';
        }

        // Generate gridpage-style full phrase options using /llm endpoint
        async function generateGridpageLLMOptions(prompt, count = null) {
            // Use LLMOptions setting if count not specified
            const optionsCount = count !== null ? count : LLMOptions;
            console.log('generateGridpageLLMOptions called with prompt:', prompt, 'count:', optionsCount);
            
            try {
                const summaryInstruction = SummaryOff
                    ? 'The "summary" key should contain the exact same FULL text as the "option" key.'
                    : 'If the generated option is more than 5 words, the "summary" key should be a 3-5 word abbreviation of each option, including the exact key words from the option. If the option is 5 words or less, the "summary" key should contain the exact same FULL text as the "option" key.';

                // Format prompt to request full phrases (similar to gridpage LLMQuery)
                const enhancedPrompt = `Generate ${optionsCount} complete communication phrases for: ${prompt}
                
                Requirements:
                - Each option should be a complete, natural sentence or phrase
                - Phrases should be ready to speak as complete communication
                - Use first person perspective as if the user is speaking
                - Make each option distinct and useful for communication
                - Focus on natural, conversational language
                
                Format your response as a JSON list where each item has "option", "summary", and "keywords" keys.
                ${summaryInstruction}
                The "keywords" key should contain 3-5 words that match available symbols.
                Example: [{"option": "What a fantastic day!", "summary": "Fantastic day", "keywords": ["good", "happy", "great", "day", "fun"]}]`;

                console.log('Sending request to /llm endpoint with enhanced prompt:', enhancedPrompt);

                const requestBody = {
                    count: optionsCount,
                    prompt: enhancedPrompt,
                    response_format: 'json'
                };

                const response = await authenticatedFetch('/llm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('LLM response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('LLM response data:', data);
                    // Response format: [{option: "full phrase", summary: "short text", keywords: []}]
                    return Array.isArray(data) ? data : [];
                } else {
                    const errorText = await response.text();
                    console.error('LLM request failed:', response.status, errorText);
                    throw new Error(`Failed to generate LLM options: ${response.status} ${errorText}`);
                }
            } catch (error) {
                console.error('Error generating gridpage LLM options:', error);
                return [];
            }
        }

        // Generate phrase options with exclusion (like gridpage)
        async function generateGridpageLLMOptionsWithExclusion(prompt, count, excludedOptionsText) {
            const optionsCount = count || LLMOptions;
            console.log('generateGridpageLLMOptionsWithExclusion called with prompt:', prompt, 'count:', optionsCount, 'excluding:', excludedOptionsText);
            
            try {
                const summaryInstruction = SummaryOff
                    ? 'The "summary" key should contain the exact same FULL text as the "option" key.'
                    : 'If the generated option is more than 5 words, the "summary" key should be a 3-5 word abbreviation of each option, including the exact key words from the option. If the option is 5 words or less, the "summary" key should contain the exact same FULL text as the "option" key.';
                
                const enhancedPrompt = `For the request "${prompt}", provide ${optionsCount} new complete communication phrases.
                IMPORTANTLY, exclude the following options if possible: "${excludedOptionsText}".
                
                Requirements:
                - Each option should be a complete, natural sentence or phrase
                - Phrases should be ready to speak as complete communication
                - Use first person perspective as if the user is speaking
                - Make each option distinct and useful for communication
                - Focus on natural, conversational language
                
                Format your response as a JSON list where each item has "option", "summary", and "keywords" keys.
                ${summaryInstruction}
                The "keywords" key should contain 3-5 words that match available symbols.
                Example: [{"option": "What a fantastic day!", "summary": "Fantastic day", "keywords": ["good", "happy", "great", "day", "fun"]}]`;
                
                console.log('Sending exclusion request to /llm endpoint with enhanced prompt:', enhancedPrompt);
                
                const requestBody = {
                    count: optionsCount,
                    prompt: enhancedPrompt,
                    response_format: 'json'
                };
                
                const response = await authenticatedFetch('/llm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('LLM exclusion response:', data);
                
                return Array.isArray(data) ? data : [];
                
            } catch (error) {
                console.error('Error in generateGridpageLLMOptionsWithExclusion:', error);
                return [];
            }
        }
        
        // Generate freestyle-style single words using category-specific endpoint
        async function generateFreestyleLLMOptions(category, count = null, wordsPrompt = null) {
            // Use FreestyleWordOptions setting if count not specified
            const wordsCount = count !== null ? count : FreestyleWordOptions;
            console.log('generateFreestyleLLMOptions called with category:', category, 'count:', wordsCount, 'wordsPrompt:', wordsPrompt);
            
            // SIMPLIFIED LOGIC: 
            // 1. If we have a words prompt AND NO category, use it as speech history context
            // 2. If we have a category (even with words prompt), use the category-words endpoint
            //    so the server can handle the custom prompt correctly
            
            if (wordsPrompt && (!category || !category.label)) {
                console.log('ðŸŽ¯ Using words prompt as Speech History context (no category):', wordsPrompt);
                return await generateWordsBasedOnSpeechHistory(wordsPrompt, count);
            }
            try {
                if (category && category.label) {
                    // Use category-words endpoint for category-specific words
                    console.log(`Generating category-specific words for: ${category.label}`);
                    // Get current mood for context
                    const currentMood = getCurrentMood ? getCurrentMood() : null;

                    const response = await authenticatedFetch('/api/freestyle/category-words', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            category: category.label,
                            build_space_content: buildSpace.value || "",
                            exclude_words: [],
                            current_mood: currentMood,
                            custom_prompt: wordsPrompt || null
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        // Response format: {words: [{text: "word", keywords: []}]}
                        console.log(`Category words response for ${category.label}:`, data);
                        return data.words || [];
                    } else {
                        throw new Error(`Failed to generate category words: ${response.status}`);
                    }
                } else {
                    // Use word-options endpoint for general words when no category
                    console.log('ðŸŸ¡ Generating general freestyle words (no category)');
                    // Get current mood for context
                    const currentMood = getCurrentMood ? getCurrentMood() : null;
                    const moodContext = currentMood && currentMood !== 'none' ? ` when feeling ${currentMood}` : '';
                    
                    console.log('ðŸŸ¡ Current mood for general words:', currentMood);
                    console.log('ðŸŸ¡ Build space content:', buildSpace.value || "(empty)");

                    const requestBody = {
                        context: `general communication${moodContext}`,
                        source_page: "tap_interface",
                        is_llm_generated: false,
                        originating_button_text: "",
                        build_space_text: buildSpace.value || "",
                        single_words_only: false,
                        request_different_options: false,
                        current_mood: currentMood
                    };
                    
                    console.log('ðŸŸ¡ Sending request to /api/freestyle/word-options:', requestBody);

                    const response = await authenticatedFetch('/api/freestyle/word-options', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });

                    console.log('ðŸŸ¡ Word-options response status:', response.status);
                    
                    if (response.ok) {
                        const data = await response.json();
                        // Response format: {word_options: [{text: "word", keywords: []}]}
                        console.log('ðŸŸ¢ General words response data:', data);
                        console.log('ðŸŸ¢ word_options array:', data.word_options);
                        console.log('ðŸŸ¢ word_options count:', data.word_options ? data.word_options.length : 0);
                        return data.word_options || [];
                    } else {
                        const errorText = await response.text();
                        console.error('ðŸ”´ Word-options API failed:', response.status, errorText);
                        throw new Error(`Failed to generate general options: ${response.status} ${errorText}`);
                    }
                }
            } catch (error) {
                console.error('Error generating freestyle options:', error);
                return [];
            }
        }

        function renderCategoryOptions(options) {
            console.log('ðŸš¨ RENDER CATEGORY OPTIONS CALLED - OPTIONS COUNT:', options ? options.length : 0);
            console.log('renderCategoryOptions called with:', options);
            console.log('llmStaticOptions element:', llmStaticOptions);
            
            if (!llmStaticOptions) {
                console.error('llmStaticOptions element not found!');
                return;
            }
            
            llmStaticOptions.innerHTML = '';
            
            // Dynamic Grid Sizing
            // Calculate rows needed based on LLMOptions and gridColumns
            // If LLMOptions is 0, hide the section
            if (LLMOptions <= 0) {
                document.querySelector('.phrases-section').style.display = 'none';
                return;
            } else {
                document.querySelector('.phrases-section').style.display = 'flex';
            }

            // Calculate actual rows needed based on options count, not just max LLMOptions
            // This prevents empty rows if fewer options are returned
            const actualOptionsCount = Math.min(options.length + 1, LLMOptions); // +1 for "Something Else"
            const rows = Math.ceil(actualOptionsCount / gridColumns);
            
            console.log(`[GRID DEBUG] Options: ${options.length}, Actual Count: ${actualOptionsCount}, Columns: ${gridColumns}, Calculated Rows: ${rows}`);

            llmStaticOptions.style.gridTemplateColumns = `repeat(${gridColumns}, 1fr)`;
            // Use explicit rows but ensure container doesn't have min-height forcing extra space
            llmStaticOptions.style.gridTemplateRows = `repeat(${rows}, 110px)`;
            llmStaticOptions.style.height = 'fit-content'; // Ensure container shrinks to fit content
            
            // Fill up to available phrase slots based on LLMOptions setting
            // Reserve one slot for "Something Else" button
            const maxPhraseOptions = Math.max(1, LLMOptions - 1);
            
            // Only iterate up to actualOptionsCount to avoid creating empty buttons
            for (let i = 0; i < actualOptionsCount; i++) {
                const btn = document.createElement('button');
                
                // Create "Something Else" button in the last slot
                if (i === actualOptionsCount - 1) {
                    console.log('ðŸš¨ CREATING PHRASE SOMETHING ELSE BUTTON - SLOT', i, 'of', actualOptionsCount);
                    btn.className = 'option-button';
                    btn.textContent = 'Something Else';
                    
                    // Apply image matching like other buttons
                    getSymbolImageForText('Something Else', ['refresh', 'more', 'other']).then(imageUrl => {
                        if (imageUrl) {
                            // Create image + text layout like other buttons
                            btn.innerHTML = '';
                            const buttonContent = document.createElement('div');
                            buttonContent.style.position = 'relative';
                            buttonContent.style.width = '100%';
                            buttonContent.style.height = '100%';
                            buttonContent.style.display = 'flex';
                            buttonContent.style.flexDirection = 'column';
                            
                            const imageContainer = document.createElement('div');
                            imageContainer.style.flex = '1';
                            imageContainer.style.width = '100%';
                            imageContainer.style.overflow = 'hidden';
                            imageContainer.style.borderRadius = '8px 8px 0 0';
                            imageContainer.style.display = 'flex';
                            imageContainer.style.alignItems = 'center';
                            imageContainer.style.justifyContent = 'center';
                            
                            const imageElement = document.createElement('img');
                            imageElement.src = imageUrl;
                            imageElement.alt = 'Something Else';
                            imageElement.style.width = '100%';
                            imageElement.style.height = '100%';
                            imageElement.style.objectFit = 'cover';
                            
                            const textFooter = document.createElement('div');
                            textFooter.style.minHeight = '22px';
                            textFooter.style.width = '100%';
                            textFooter.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
                            textFooter.style.backdropFilter = 'blur(4px)';
                            textFooter.style.color = 'white';
                            textFooter.style.display = 'flex';
                            textFooter.style.alignItems = 'center';
                            textFooter.style.justifyContent = 'center';
                            textFooter.style.padding = '2px 4px';
                            textFooter.style.fontSize = '10px';
                            textFooter.style.fontWeight = '600';
                            textFooter.textContent = 'Something Else';
                            
                            imageContainer.appendChild(imageElement);
                            buttonContent.appendChild(imageContainer);
                            buttonContent.appendChild(textFooter);
                            btn.appendChild(buttonContent);
                        }
                    });
                    
                    btn.onclick = async () => {
                        console.log('ðŸ”„ Something Else clicked for phrases');
                        await regeneratePhraseOptions();
                    };
                    
                    llmStaticOptions.appendChild(btn);
                    continue;
                }
                
                btn.className = 'option-button';
                
                if (i < Math.min(options.length, maxPhraseOptions) && options[i]) {
                    const option = options[i];
                    let displayText, speechText, fullOption;
                    
                    // Handle both structured options (from /llm endpoint) and simple strings
                    if (typeof option === 'object' && option.summary && option.option) {
                        // Structured option with summary and full option
                        fullOption = option.option;
                        speechText = option.option; // Full text for speech
                        
                        console.log(`[TEXT DEBUG] Option: "${option.option}", Summary: "${option.summary}", SummaryOff: ${SummaryOff}`);

                        // Use SummaryOff setting to determine display text (like gridpage)
                        // STRICTLY use summary if SummaryOff is false and summary exists
                        if (!SummaryOff && option.summary) {
                            displayText = option.summary;
                        } else {
                            displayText = option.option;
                        }
                    } else {
                        // Simple string option
                        const text = typeof option === 'string' ? option : (option.text || option.option || '');
                        displayText = text;
                        speechText = text;
                        fullOption = text;
                    }
                    
                    // Check if displayText is a sight word - if so, skip image loading
                    const isSightWord = window.isSightWord && window.isSightWord(displayText);
                    
                    // Add Firestore image support (like gridpage) - skip for sight words
                    if (!isSightWord) {
                        console.log(`ðŸ” Attempting image load for phrase: "${speechText}"`);
                        const phraseKeywords = (typeof option === 'object' && option.keywords) ? option.keywords : null;
                        getSymbolImageForText(speechText, phraseKeywords).then(imageUrl => {
                            console.log(`ðŸŽ¯ Image result for "${speechText}": ${imageUrl ? 'Found' : 'Not found'}`);
                            if (imageUrl) {
                            // Create image + text layout like gridpage
                            btn.innerHTML = '';
                            const buttonContent = document.createElement('div');
                            buttonContent.style.position = 'relative';
                            buttonContent.style.width = '100%';
                            buttonContent.style.height = '100%';
                            buttonContent.style.display = 'flex';
                            buttonContent.style.flexDirection = 'column';
                            
                            const imageContainer = document.createElement('div');
                            imageContainer.style.flex = '1';
                            imageContainer.style.width = '100%';
                            imageContainer.style.overflow = 'hidden';
                            imageContainer.style.borderRadius = '8px 8px 0 0';
                            imageContainer.style.display = 'flex';
                            imageContainer.style.alignItems = 'center';
                            imageContainer.style.justifyContent = 'center';
                            
                            const imageElement = document.createElement('img');
                            imageElement.src = imageUrl;
                            imageElement.alt = displayText;
                            imageElement.style.width = '100%';
                            imageElement.style.height = '100%';
                            imageElement.style.objectFit = 'cover';
                            
                            const textFooter = document.createElement('div');
                            textFooter.style.minHeight = '22px';
                            textFooter.style.width = '100%';
                            textFooter.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
                            textFooter.style.backdropFilter = 'blur(4px)';
                            textFooter.style.color = 'white';
                            textFooter.style.display = 'flex';
                            textFooter.style.alignItems = 'center';
                            textFooter.style.justifyContent = 'center';
                            textFooter.style.padding = '2px 4px';
                            textFooter.style.zIndex = '10';
                            
                            const textSpan = document.createElement('span');
                            textSpan.textContent = displayText;
                            textSpan.style.fontSize = '0.7em';
                            textSpan.style.fontWeight = 'bold';
                            textSpan.style.textAlign = 'center';
                            
                            imageContainer.appendChild(imageElement);
                            textFooter.appendChild(textSpan);
                            buttonContent.appendChild(imageContainer);
                            buttonContent.appendChild(textFooter);
                            btn.appendChild(buttonContent);
                        }
                        }).catch(error => {
                            console.error('Error loading image for phrase button:', error);
                        });
                    }
                    
                    // Set initial text (will be replaced by image if found)
                    // For sight words, apply special styling
                    if (isSightWord) {
                        console.log('[SIGHT WORD] Rendering text-only phrase button for:', displayText);
                        btn.classList.add('sight-word-button');
                        const textSpan = document.createElement('span');
                        textSpan.textContent = displayText;
                        textSpan.style.fontSize = '1.00em';
                        textSpan.style.fontWeight = '900';
                        textSpan.style.color = '#dc2626';
                        btn.appendChild(textSpan);
                    } else {
                        btn.textContent = displayText;
                    }
                    
                    btn.title = fullOption; // Show full text on hover
                    btn.addEventListener('click', async () => {
                        addToSpeech(speechText);
                        // Announce the speech text when phrase is selected
                        await announce(speechText, "system", true);
                    });
                } else {
                    btn.classList.add('empty-state');
                    btn.textContent = 'â€”';
                }
                
                llmStaticOptions.appendChild(btn);
            }
        }

        async function loadFreestyleOptions() {
            console.log('ðŸŸ¡ loadFreestyleOptions called - loading initial freestyle options');
            try {
                // Clear any current words prompt since we're loading general options
                currentWordsPrompt = null;
                // Store a general category for Something Else regeneration
                currentCategory = { label: 'general' };
                // Generate initial freestyle options (general communication words)
                console.log('ðŸŸ¡ Calling generateFreestyleLLMOptions with null category...');
                const options = await generateFreestyleLLMOptions(null, 29);
                console.log('ðŸŸ¢ Generated initial freestyle options:', options);
                console.log('ðŸŸ¢ Options count:', options ? options.length : 0);
                renderFreestyleOptions(options);
            } catch (error) {
                console.error('ðŸ”´ Error loading freestyle options:', error);
                renderFreestyleOptions([]);
            }
        }

        async function updateFreestyleOptionsWithContext(categoryOrPath, initial = false, wordsPrompt = null, instructionPrompt = null) {
            console.log('updateFreestyleOptionsWithContext called with:', categoryOrPath, 'initial:', initial, 'wordsPrompt:', wordsPrompt, 'instructionPrompt:', instructionPrompt);
            try {
                // If this is the initial category selection, use the dedicated category-words endpoint
                if (initial) {
                    console.log('Using category-specific words for:', categoryOrPath);
                    // categoryOrPath may be an object or a string full path
                    const categoryPath = (typeof categoryOrPath === 'string') ? categoryOrPath : (categoryOrPath.label || '');
                    const options = await generateFreestyleOptionsForCategory(categoryPath, 29, wordsPrompt, instructionPrompt);
                    renderFreestyleOptions(options);
                    return;
                }

                // Otherwise use the freestyle /word-options endpoint which uses navigation/build-space context
                const options = await generateFreestyleLLMOptions(typeof categoryOrPath === 'string' ? { label: categoryOrPath } : categoryOrPath, 29, wordsPrompt);
                renderFreestyleOptions(options);
            } catch (error) {
                console.error('Error updating freestyle options with context:', error);
            }
        }

        // Use the category-specific endpoint to get words for a category path. This should be called
        // only on the initial category selection to get category-focused single words.
        async function generateFreestyleOptionsForCategory(categoryFullPath, count = 29, wordsPrompt = null, instructionPrompt = null) {
            console.log('generateFreestyleOptionsForCategory called with path:', categoryFullPath, 'count:', count, 'wordsPrompt:', wordsPrompt, 'instructionPrompt:', instructionPrompt);
            
            try {
                // Get current mood for context
                const currentMood = getCurrentMood ? getCurrentMood() : null;
                console.log('Current mood for context:', currentMood);

                // Prepare build space content
                let buildSpaceContent = buildSpace.value || "";
                
                // NOTE: Words Prompt logic removed as per user request (it wasn't working as expected).
                // We keep the variable passed in case we want to re-enable it later.
                /*
                if (wordsPrompt) {
                    // Append wordsPrompt to buildSpaceContent to guide prediction
                    if (buildSpaceContent && !buildSpaceContent.endsWith(' ')) {
                        buildSpaceContent += ' ';
                    }
                    buildSpaceContent += wordsPrompt;
                    console.log('Appended wordsPrompt to context:', buildSpaceContent);
                }
                */

                // IMPORTANT: Use instructionPrompt (from Phrase Prompt) as the custom_prompt if available
                // Use wordsPrompt as context (appended to build space), NOT as the instruction
                const requestBody = {
                    category: categoryFullPath,
                    build_space_content: buildSpaceContent,
                    exclude_words: [],
                    current_mood: currentMood,
                    custom_prompt: instructionPrompt || null  // Use instructionPrompt for server priority
                };
                
                console.log('Sending request to category-words:', requestBody);

                const response = await authenticatedFetch('/api/freestyle/category-words', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Category-words API response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Category-words API response data:', data);
                    // Response format: {words: [{text: "word", keywords: []}]}
                    return data.words || [];
                } else {
                    const errorText = await response.text();
                    console.error('Category-words API failed:', response.status, errorText);
                    throw new Error(`Failed to generate category freestyle options: ${response.status} ${errorText}`);
                }
            } catch (error) {
                console.error('Error generating freestyle options for category:', error);
                return [];
            }
        }

        // DEPRECATED: This function is now replaced by generateWordsBasedOnSpeechHistory
        // Generate word options using a custom prompt from tap navigation button  
        async function generateCustomWordOptions(wordsPrompt, count = 29) {
            console.log('generateCustomWordOptions called with prompt:', wordsPrompt, 'count:', count);
            try {
                // Get current mood for context
                const currentMood = getCurrentMood ? getCurrentMood() : null;
                
                // CRITICAL: Use the word prompt as the build_space_text directly
                // This exactly matches how freestyle.js works - when user types "Who" in build space,
                // it sends build_space_text: "Who" to get continuations like "is there", "is that"
                console.log('Using word prompt as build_space_text (freestyle.js method):', wordsPrompt);

                // Use the EXACT same request format as freestyle.js
                const requestBody = {
                    build_space_text: wordsPrompt,  // This is the key - exactly like freestyle.js
                    context: null,  // Let the backend determine context from build_space_text
                    source_page: null,  // Keep it simple like freestyle.js
                    is_llm_generated: false,
                    originating_button_text: null,  // Don't confuse the backend with extra context
                    current_mood: currentMood,
                    max_options: count,
                    single_words_only: false  // Allow phrases for continuations
                };
                
                console.log('Sending request matching freestyle.js format:', requestBody);

                const response = await authenticatedFetch('/api/freestyle/word-options', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Word options response (freestyle.js format):', data);
                    console.log('Word options count received:', data.word_options ? data.word_options.length : 0);
                    console.log('Full word options array:', data.word_options);
                    
                    // Response format: {word_options: [{text: "word", keywords: []}]}
                    let options = data.word_options || [];
                    
                    // If we get back full phrases, try to extract just the continuation parts
                    if (options.length > 0 && options.some(opt => opt.text.toLowerCase().startsWith(wordsPrompt.toLowerCase()))) {
                        console.log('âš ï¸ Detected full phrases, extracting continuations...');
                        options = options.map(opt => {
                            if (opt.text.toLowerCase().startsWith(wordsPrompt.toLowerCase())) {
                                // Extract the part after the prompt word
                                const continuation = opt.text.substring(wordsPrompt.length).trim();
                                if (continuation) {
                                    return {
                                        text: continuation,
                                        keywords: opt.keywords || []
                                    };
                                }
                            }
                            return opt;
                        }).filter(opt => opt.text && opt.text !== wordsPrompt);
                    }
                    
                    if (options.length === 0 || (options.length === 1 && options[0].text === wordsPrompt)) {
                        console.error('âš ï¸ API returned only the original prompt or no valid continuations - this indicates a backend processing issue');
                        console.log('Request that caused this issue:', requestBody);
                        console.log('Raw response that caused this issue:', data);
                        
                        // Return some fallback continuations based on the word prompt
                        const fallbackOptions = getFallbackContinuations(wordsPrompt);
                        console.log('Using fallback continuations:', fallbackOptions);
                        return fallbackOptions;
                    }
                    
                    return options;
                } else {
                    const errorText = await response.text();
                    console.error('Custom words API failed:', response.status, errorText);
                    throw new Error(`Failed to generate custom word options: ${response.status} ${errorText}`);
                }
            } catch (error) {
                console.error('Error generating custom word options:', error);
                return [];
            }
        }
        
        // SIMPLIFIED: Use exact same logic as freestyle.js
        
        // Generate words based on what's currently in Speech History - EXACTLY like freestyle.js
        async function generateWordsBasedOnSpeechHistory(speechText, count = 29) {
            console.log('ðŸŽ¯ Using FREESTYLE.JS logic for:', speechText);
            try {
                // Use the EXACT same requestPayload structure as freestyle.js line 935-942
                const requestPayload = {
                    build_space_text: speechText,  // This is the key - exactly like freestyle.js
                    context: null,  // Keep simple like freestyle.js
                    source_page: null,  // Keep simple like freestyle.js
                    is_llm_generated: false,
                    originating_button_text: null
                };
                
                console.log('ðŸŽ¯ Using freestyle.js requestPayload format:', requestPayload);
                
                const response = await authenticatedFetch('/api/freestyle/word-options', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestPayload)
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('ðŸŽ¯ Freestyle.js format response:', data.word_options?.length || 0, 'options');
                    return data.word_options || [];
                } else {
                    console.error('Freestyle.js format API failed:', response.status);
                    return getFallbackWordsForSpeech(speechText);
                }
            } catch (error) {
                console.error('Error with freestyle.js format:', error);
                return getFallbackWordsForSpeech(speechText);
            }
        }
        
        // Generate general starter words when no context
        async function generateGeneralStarterWords(count = 29) {
            console.log('ðŸŽ¯ Generating general starter words');
            try {
                const currentMood = getCurrentMood ? getCurrentMood() : null;
                
                const requestBody = {
                    build_space_text: "",  // Empty - ask for starter words
                    context: null,
                    source_page: null,
                    is_llm_generated: false,
                    originating_button_text: null,
                    current_mood: currentMood,
                    max_options: count,
                    single_words_only: false
                };
                
                const response = await authenticatedFetch('/api/freestyle/word-options', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('ðŸŽ¯ General starter words response:', data.word_options?.length || 0, 'options');
                    return data.word_options || [];
                } else {
                    console.error('General starter words API failed:', response.status);
                    return getFallbackStarterWords();
                }
            } catch (error) {
                console.error('Error generating general starter words:', error);
                return getFallbackStarterWords();
            }
        }
        
        // --- Spelling Feature Logic ---
        let currentSpellingWord = "";
        let currentPredictions = [];
        let isSpellingModalOpen = false;

        function setupSpellingModal() {
            // Setup close modal listeners
            document.getElementById('cancel-spelling-btn').addEventListener('click', closeSpellingModal);
            document.getElementById('spelling-modal').addEventListener('click', (e) => {
                if (e.target.id === 'spelling-modal') {
                    closeSpellingModal();
                }
            });
            
            // Setup word control buttons
            document.getElementById('add-word-btn').addEventListener('click', addCurrentWordToBuildSpace);
            document.getElementById('clear-word-btn').addEventListener('click', clearCurrentWord);
            document.getElementById('backspace-btn').addEventListener('click', backspaceCurrentWord);
        }

        function openSpellingModal() {
            isSpellingModalOpen = true;
            document.getElementById('spelling-modal').style.display = 'flex';
            document.getElementById('spelling-modal').classList.remove('hidden');
            currentSpellingWord = "";
            document.getElementById('current-word').value = "";
            
            // Generate alphabet grid using current settings
            generateAlphabetGrid();
            
            // Initialize smart letter filtering
            updateLetterAvailability("");
            
            // Clear predictions
            currentPredictions = [];
            renderWordPredictions();
        }

        function closeSpellingModal() {
            isSpellingModalOpen = false;
            document.getElementById('spelling-modal').style.display = 'none';
            document.getElementById('spelling-modal').classList.add('hidden');
        }

        function generateAlphabetGrid() {
            const grid = document.getElementById('alphabet-grid');
            
            // Define different letter orders based on the loaded setting
            let letters;
            let gridColumns;
            
            console.log('Generating alphabet grid with order:', spellLetterOrder);
            
            if (spellLetterOrder === 'qwerty') {
                // QWERTY keyboard layout
                letters = [
                    ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                    ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                    ['Z', 'X', 'C', 'V', 'B', 'N', 'M']
                ];
                gridColumns = 10; // Max columns for first row
            } else if (spellLetterOrder === 'frequency') {
                // Frequency-based order: ETAOIN SHRDLU CMFWGY P BVKX JZQ
                const frequencyOrder = 'ETAOINSHRDLUCMFWGYPBVKXJZQ';
                letters = frequencyOrder.split('');
                gridColumns = 6; // Standard grid
            } else {
                // Alphabetical (default)
                letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                gridColumns = 6; // Standard grid
            }
            
            grid.innerHTML = ''; // Clear existing
            
            // Update grid columns CSS
            if (spellLetterOrder === 'qwerty') {
                // QWERTY layout requires special grid formatting
                grid.style.gridTemplateColumns = 'repeat(10, 1fr)';
                grid.style.justifyItems = 'stretch';
                
                // Create rows for QWERTY layout
                letters.forEach((row, rowIndex) => {
                    row.forEach((letter, colIndex) => {
                        const button = document.createElement('button');
                        button.className = 'letter-btn';
                        button.textContent = letter;
                        button.setAttribute('data-letter', letter);
                        button.addEventListener('click', () => handleLetterClick(letter));
                        
                        // Handle centering for shorter rows
                        if (rowIndex === 1 && colIndex === 0) {
                            // A starts at column 1 (offset by 0.5)
                            button.style.gridColumn = '1 / span 1';
                            button.style.marginLeft = '5%';
                        } else if (rowIndex === 2 && colIndex === 0) {
                            // Z starts at column 2 (offset by 1.5)
                            button.style.gridColumn = '2 / span 1';
                        }
                        
                        grid.appendChild(button);
                    });
                });
            } else {
                // Standard grid layout for alphabetical and frequency
                // Use 7 columns for better sizing similar to QWERTY
                grid.style.gridTemplateColumns = 'repeat(7, 1fr)';
                grid.style.justifyItems = 'stretch';
                
                letters.forEach((letter, index) => {
                    const button = document.createElement('button');
                    button.className = 'letter-btn';
                    button.textContent = letter;
                    button.setAttribute('data-letter', letter);
                    button.setAttribute('data-index', index);
                    button.addEventListener('click', () => handleLetterClick(letter));
                    grid.appendChild(button);
                });
            }
        }

        async function handleLetterClick(letter) {
            currentSpellingWord += letter.toLowerCase();
            document.getElementById('current-word').value = currentSpellingWord;
            
            // Update letter availability immediately
            updateLetterAvailability(currentSpellingWord);
            
            // Get word predictions
            await getWordPredictionsForSpelling();
        }

        async function getWordPredictionsForSpelling() {
            try {
                const currentSpeech = buildSpace.value.trim();
                
                // Send spelling word and build space separately to ensure full word predictions
                const response = await authenticatedFetch('/api/freestyle/word-prediction', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: currentSpeech || "", // Context from build space
                        spelling_word: currentSpellingWord || "", // Current partial word
                        predict_full_words: true // Flag to ensure complete words are returned
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentPredictions = data.predictions || [];
                    renderWordPredictions();
                } else {
                    console.error('Failed to get word predictions:', response.statusText);
                    currentPredictions = [];
                    renderWordPredictions();
                }
            } catch (error) {
                console.error('Error getting word predictions:', error);
                currentPredictions = [];
                renderWordPredictions();
            }
        }

        function renderWordPredictions() {
            const grid = document.getElementById('word-predictions');
            grid.innerHTML = '';
            
            currentPredictions.forEach((word, index) => {
                const button = document.createElement('button');
                button.className = 'prediction-btn';
                button.textContent = word;
                button.setAttribute('data-index', index);
                button.addEventListener('click', () => handlePredictionClick(word));
                grid.appendChild(button);
            });
        }

        async function handlePredictionClick(word) {
            // Announce the selected word
            await announce(word, "system", true);
            
            // Add word to build space and close modal
            addWordToBuildSpaceInternal(word);
            clearCurrentWord();
            closeSpellingModal();
        }

        async function addCurrentWordToBuildSpace() {
            if (currentSpellingWord.trim()) {
                // Announce the selected word
                await announce(currentSpellingWord, "system", true);
                
                addWordToBuildSpaceInternal(currentSpellingWord);
                clearCurrentWord();
                closeSpellingModal();
            }
        }

        function addWordToBuildSpaceInternal(word) {
            const currentText = buildSpace.value.trim();
            const newText = currentText ? currentText + ' ' + word : word;
            buildSpace.value = newText;
            
            // Trigger update of word options
            updateFreestyleOptionsWithSelectedWord(word);
        }

        function clearCurrentWord() {
            currentSpellingWord = "";
            document.getElementById('current-word').value = "";
            
            // Reset letter availability
            updateLetterAvailability("");
            
            currentPredictions = [];
            renderWordPredictions();
        }

        function backspaceCurrentWord() {
            if (currentSpellingWord.length > 0) {
                currentSpellingWord = currentSpellingWord.slice(0, -1);
                document.getElementById('current-word').value = currentSpellingWord;
                
                // Update letter availability immediately
                updateLetterAvailability(currentSpellingWord);
                
                getWordPredictionsForSpelling();
            }
        }

        // --- Smart Letter Filtering ---
        function getValidLetters(currentWord) {
            if (!currentWord || currentWord.length === 0) {
                return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            }
            
            const lastChar = currentWord.slice(-1).toUpperCase();
            const lastTwoChars = currentWord.slice(-2).toUpperCase();
            
            // Define likely letter combinations based on common English patterns
            const likelyAfter = {
                'A': ['B', 'C', 'D', 'F', 'G', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'V', 'W', 'Y'],
                'B': ['A', 'E', 'I', 'L', 'O', 'R', 'U', 'Y'],
                'C': ['A', 'E', 'H', 'I', 'L', 'O', 'R', 'U'],
                'D': ['A', 'E', 'I', 'O', 'R', 'U', 'Y'],
                'E': ['A', 'D', 'L', 'M', 'N', 'R', 'S', 'T', 'V', 'W', 'X'],
                'F': ['A', 'E', 'I', 'L', 'O', 'R', 'U'],
                'G': ['A', 'E', 'I', 'L', 'O', 'R', 'U'],
                'H': ['A', 'E', 'I', 'O', 'U', 'Y'],
                'I': ['C', 'D', 'F', 'G', 'L', 'M', 'N', 'R', 'S', 'T'],
                'J': ['A', 'E', 'O', 'U'],
                'K': ['A', 'E', 'I', 'N'],
                'L': ['A', 'E', 'I', 'O', 'U', 'Y'],
                'M': ['A', 'E', 'I', 'O', 'U', 'Y'],
                'N': ['A', 'C', 'D', 'E', 'G', 'I', 'K', 'O', 'S', 'T', 'U', 'Y', 'Z'],
                'O': ['B', 'C', 'D', 'F', 'G', 'K', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'V', 'W'],
                'P': ['A', 'E', 'I', 'L', 'O', 'R', 'U'],
                'Q': ['U'],
                'R': ['A', 'E', 'I', 'O', 'U', 'Y'],
                'S': ['A', 'C', 'E', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'P', 'T', 'U', 'W'],
                'T': ['A', 'E', 'H', 'I', 'O', 'R', 'U', 'W'],
                'U': ['B', 'C', 'G', 'L', 'M', 'N', 'P', 'R', 'S', 'T'],
                'V': ['A', 'E', 'I', 'O'],
                'W': ['A', 'E', 'H', 'I', 'O'],
                'X': ['A', 'E', 'I'],
                'Y': ['A', 'E', 'O', 'U'],
                'Z': ['A', 'E', 'I', 'O']
            };
            
            const likelyAfterTwoLetters = {
                'TH': ['A', 'E', 'I', 'O', 'R'],
                'CH': ['A', 'E', 'I', 'O', 'U'],
                'SH': ['A', 'E', 'I', 'O', 'U'],
                'WH': ['A', 'E', 'I', 'O', 'U'],
                'PH': ['A', 'E', 'I', 'O', 'U'],
                'ST': ['A', 'E', 'I', 'O', 'R', 'U'],
                'SP': ['A', 'E', 'I', 'O', 'R'],
                'SC': ['A', 'E', 'I', 'O', 'R'],
                'FL': ['A', 'E', 'I', 'O', 'U'],
                'BL': ['A', 'E', 'I', 'O', 'U'],
                'CL': ['A', 'E', 'I', 'O', 'U'],
                'GL': ['A', 'E', 'I', 'O', 'U'],
                'PL': ['A', 'E', 'I', 'O', 'U'],
                'BR': ['A', 'E', 'I', 'O', 'U'],
                'CR': ['A', 'E', 'I', 'O', 'U'],
                'DR': ['A', 'E', 'I', 'O', 'U'],
                'FR': ['A', 'E', 'I', 'O', 'U'],
                'GR': ['A', 'E', 'I', 'O', 'U'],
                'PR': ['A', 'E', 'I', 'O', 'U'],
                'TR': ['A', 'E', 'I', 'O', 'U'],
                'ON': ['A', 'C', 'D', 'E', 'G', 'K', 'S', 'T', 'Y', 'Z'],
                'RO': ['A', 'B', 'C', 'D', 'E', 'G', 'L', 'M', 'N', 'O', 'P', 'S', 'T', 'U', 'W'],
                'RN': ['A', 'E', 'I', 'O'],
            };
            
            let validLetters = [];
            
            if (currentWord.length >= 4) {
                // Simplified logic for long words - allow most common letters
                validLetters = 'ABCDEFGHIKLMNOPRSTUVWYZ'.split('');
            }
            else if (currentWord.length >= 2 && likelyAfterTwoLetters[lastTwoChars]) {
                validLetters = likelyAfterTwoLetters[lastTwoChars];
            }
            else if (likelyAfter[lastChar]) {
                validLetters = likelyAfter[lastChar];
            }
            else {
                validLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            }
            
            return validLetters;
        }

        function updateLetterAvailability(currentWord) {
            const validLetters = getValidLetters(currentWord);
            const letterButtons = document.querySelectorAll('.letter-btn');
            
            letterButtons.forEach(button => {
                const letter = button.textContent.toUpperCase();
                if (validLetters.includes(letter)) {
                    button.classList.remove('disabled-letter');
                    button.disabled = false;
                } else {
                    button.classList.add('disabled-letter');
                    button.disabled = true;
                }
            });
        }

        // Fallback words when API fails
        function getFallbackWordsForSpeech(speechText) {
            // Simple fallbacks based on common sentence patterns
            if (speechText.toLowerCase().includes('who')) {
                return [
                    { text: 'is there', keywords: ['person'] },
                    { text: 'are you', keywords: ['person'] },
                    { text: 'can help', keywords: ['help'] }
                ];
            } else if (speechText.toLowerCase().includes('what')) {
                return [
                    { text: 'is that', keywords: ['question'] },
                    { text: 'are you doing', keywords: ['activity'] },
                    { text: 'do you want', keywords: ['want'] }
                ];
            } else {
                return [
                    { text: 'please', keywords: ['polite'] },
                    { text: 'thank you', keywords: ['thanks'] },
                    { text: 'help me', keywords: ['help'] }
                ];
            }
        }
        
        function getFallbackStarterWords() {
            return [
                { text: "I", keywords: ["person"] },
                { text: "want", keywords: ["desire"] },
                { text: "need", keywords: ["need"] },
                { text: "like", keywords: ["happy"] },
                { text: "go", keywords: ["travel"] },
                { text: "see", keywords: ["eye"] },
                { text: "help", keywords: ["help"] },
                { text: "more", keywords: ["plus"] },
                { text: "please", keywords: ["polite"] },
                { text: "thank you", keywords: ["thanks"] }
            ];
        }

        async function updateFreestyleOptionsWithSelectedWord(selectedWord) {
            try {
                // Clear words prompt since we're now using Speech History context
                currentWordsPrompt = null;
                
                // Get current speech history - this is the key!
                const currentSpeech = buildSpace.value.trim();
                console.log('ðŸŽ¯ Updating word options based on current Speech History:', currentSpeech);
                
                // Generate new options based on what's currently in the Speech History
                let options;
                if (currentSpeech) {
                    options = await generateWordsBasedOnSpeechHistory(currentSpeech, 29);
                } else {
                    options = await generateGeneralStarterWords(29);
                }
                
                renderFreestyleOptions(options);
            } catch (error) {
                console.error('Error updating freestyle options with selected word:', error);
            }
        }

        function renderFreestyleOptions(options = []) {
            console.log('ðŸš¨ RENDER FREESTYLE OPTIONS CALLED - OPTIONS COUNT:', options.length);
            console.log('renderFreestyleOptions called with', options.length, 'options:', options);
            console.log('freestyleOptions element:', freestyleOptions);
            
            // Store current options for exclusion in Something Else
            currentWordOptions = options.slice(); // Create a copy
            
            if (!freestyleOptions) {
                console.error('freestyleOptions element not found!');
                return;
            }
            
            freestyleOptions.innerHTML = '';

            // Dynamic Grid Sizing for Freestyle
            freestyleOptions.style.gridTemplateColumns = `repeat(${gridColumns}, 1fr)`;
            
            // Calculate rows needed based on FreestyleWordOptions and gridColumns
            const rows = Math.ceil(FreestyleWordOptions / gridColumns);
            freestyleOptions.style.gridTemplateRows = `repeat(${rows}, 110px)`;
            
            // Create freestyle slots based on FreestyleWordOptions setting
            // Reserve one slot for "Something Else" button
            const maxWordOptions = Math.max(1, FreestyleWordOptions - 1);
            
            for (let i = 0; i < FreestyleWordOptions; i++) {
                const btn = document.createElement('button');
                
                // Create "Something Else" button in the last slot
                if (i === FreestyleWordOptions - 1) {
                    console.log('ðŸš¨ CREATING WORD SOMETHING ELSE BUTTON - SLOT', i, 'of', FreestyleWordOptions);
                    btn.className = 'option-button freestyle-button';
                    btn.textContent = 'Something Else';
                    
                    // Apply image matching like other buttons
                    getSymbolImageForText('Something Else', ['refresh', 'more', 'other']).then(imageUrl => {
                        if (imageUrl) {
                            // Create image + text layout like other buttons
                            btn.innerHTML = '';
                            const buttonContent = document.createElement('div');
                            buttonContent.style.position = 'relative';
                            buttonContent.style.width = '100%';
                            buttonContent.style.height = '100%';
                            buttonContent.style.display = 'flex';
                            buttonContent.style.flexDirection = 'column';
                            
                            const imageContainer = document.createElement('div');
                            imageContainer.style.flex = '1';
                            imageContainer.style.width = '100%';
                            imageContainer.style.overflow = 'hidden';
                            imageContainer.style.borderRadius = '8px 8px 0 0';
                            imageContainer.style.display = 'flex';
                            imageContainer.style.alignItems = 'center';
                            imageContainer.style.justifyContent = 'center';
                            
                            const imageElement = document.createElement('img');
                            imageElement.src = imageUrl;
                            imageElement.alt = 'Something Else';
                            imageElement.style.width = '100%';
                            imageElement.style.height = '100%';
                            imageElement.style.objectFit = 'cover';
                            
                            const textFooter = document.createElement('div');
                            textFooter.style.minHeight = '22px';
                            textFooter.style.width = '100%';
                            textFooter.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
                            textFooter.style.backdropFilter = 'blur(4px)';
                            textFooter.style.color = 'white';
                            textFooter.style.display = 'flex';
                            textFooter.style.alignItems = 'center';
                            textFooter.style.justifyContent = 'center';
                            textFooter.style.padding = '2px 4px';
                            textFooter.style.fontSize = '10px';
                            textFooter.style.fontWeight = '600';
                            textFooter.textContent = 'Something Else';
                            
                            imageContainer.appendChild(imageElement);
                            buttonContent.appendChild(imageContainer);
                            buttonContent.appendChild(textFooter);
                            btn.appendChild(buttonContent);
                        }
                    });
                    
                    btn.onclick = async () => {
                        console.log('ðŸ”„ Something Else clicked for words');
                        await regenerateWordOptions();
                    };
                    
                    freestyleOptions.appendChild(btn);
                    continue;
                }
                
                btn.className = 'option-button freestyle-button';
                
                if (i < Math.min(options.length, maxWordOptions) && options[i]) {
                    const option = options[i];
                    // Handle freestyle word format {text: "word", keywords: []}
                    const text = option.text || option;
                    
                    // Check if this is a sight word - if so, skip image loading
                    const isSightWord = window.isSightWord && window.isSightWord(text);
                    
                    // Add Firestore image support for words (like gridpage) - skip for sight words
                    if (!isSightWord) {
                        console.log(`ðŸ” Attempting image load for word: "${text}"`);
                        getSymbolImageForText(text).then(imageUrl => {
                            console.log(`ðŸŽ¯ Image result for "${text}": ${imageUrl ? 'Found' : 'Not found'}`);
                            if (imageUrl) {
                                // Create image + text layout like gridpage
                                btn.innerHTML = '';
                                const buttonContent = document.createElement('div');
                                buttonContent.style.position = 'relative';
                                buttonContent.style.width = '100%';
                                buttonContent.style.height = '100%';
                                buttonContent.style.display = 'flex';
                                buttonContent.style.flexDirection = 'column';
                                
                                const imageContainer = document.createElement('div');
                                imageContainer.style.flex = '1';
                                imageContainer.style.width = '100%';
                                imageContainer.style.overflow = 'hidden';
                                imageContainer.style.borderRadius = '8px 8px 0 0';
                                imageContainer.style.display = 'flex';
                                imageContainer.style.alignItems = 'center';
                                imageContainer.style.justifyContent = 'center';
                                
                                const imageElement = document.createElement('img');
                                imageElement.src = imageUrl;
                                imageElement.alt = text;
                                imageElement.style.width = '100%';
                                imageElement.style.height = '100%';
                                imageElement.style.objectFit = 'cover';
                                
                                const textFooter = document.createElement('div');
                                textFooter.style.minHeight = '22px';
                                textFooter.style.width = '100%';
                                textFooter.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
                                textFooter.style.backdropFilter = 'blur(4px)';
                                textFooter.style.color = 'white';
                                textFooter.style.display = 'flex';
                                textFooter.style.alignItems = 'center';
                                textFooter.style.justifyContent = 'center';
                                textFooter.style.padding = '2px 4px';
                                textFooter.style.zIndex = '10';
                                
                                const textSpan = document.createElement('span');
                                textSpan.textContent = text;
                                textSpan.style.fontSize = '0.7em';
                                textSpan.style.fontWeight = 'bold';
                                textSpan.style.textAlign = 'center';
                                
                                imageContainer.appendChild(imageElement);
                                textFooter.appendChild(textSpan);
                                buttonContent.appendChild(imageContainer);
                                buttonContent.appendChild(textFooter);
                                btn.appendChild(buttonContent);
                            }
                        }).catch(error => {
                            console.error('Error loading image for word button:', error);
                        });
                    }
                    
                    // Set initial text (will be replaced by image if found)
                    // For sight words, apply special styling
                    if (isSightWord) {
                        console.log('[SIGHT WORD] Rendering text-only freestyle button for:', text);
                        btn.classList.add('sight-word-button');
                        const textSpan = document.createElement('span');
                        textSpan.textContent = text;
                        textSpan.style.fontSize = '1.25em';
                        textSpan.style.fontWeight = '900';
                        textSpan.style.color = '#dc2626';
                        btn.appendChild(textSpan);
                    } else {
                        btn.textContent = text;
                    }
                    
                    btn.addEventListener('click', async () => {
                        // SIMPLIFIED LOGIC: 
                        // 1. If there's a word prompt, combine it with the selection
                        // 2. Add the result to Speech History and announce it
                        // 3. Generate new options based on the updated Speech History
                        
                        let phraseToAdd, phraseToAnnounce;
                        
                        if (currentWordsPrompt) {
                            // Combine word prompt with selected option
                            phraseToAdd = `${currentWordsPrompt} ${text}`;
                            phraseToAnnounce = phraseToAdd;
                            console.log('ðŸŽ¯ Combining words prompt + selection:', currentWordsPrompt, '+', text, '=', phraseToAdd);
                        } else {
                            // No word prompt, use selection as-is
                            phraseToAdd = text;
                            phraseToAnnounce = text;
                            console.log('ðŸŽ¯ Using selection as-is:', text);
                        }
                        
                        // Add to Speech History and announce
                        addToSpeech(phraseToAdd);
                        await announce(phraseToAnnounce, "system", true);
                        
                        // CRITICAL: Generate next options based on the UPDATED Speech History
                        // This ensures continuity in the conversation
                        console.log('ðŸŽ¯ Generating next options based on updated Speech History:', buildSpace.value);
                        await updateFreestyleOptionsWithSelectedWord(text);
                    });
                } else {
                    // Empty slot - show dash or make invisible
                    btn.classList.add('empty-state');
                    btn.textContent = 'â€”';
                    btn.disabled = true;
                }
                
                freestyleOptions.appendChild(btn);
            }
        }

        // Removed promptForFreestyleWord function - no longer needed

        // Speech synthesis enablement
        function enableSpeechSynthesis() {
            // Initialize audio context for TTS playback
            if (!audioContextInitialized) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    audioContextInitialized = true;
                    console.log("Audio context initialized by user gesture");
                } catch (error) {
                    console.warn("Could not initialize audio context:", error);
                }
            }
            
            // Also enable legacy speech synthesis as fallback
            if (!speechSynthesisEnabled && 'speechSynthesis' in window) {
                try {
                    // Create a test utterance to enable speech synthesis
                    const testUtterance = new SpeechSynthesisUtterance('');
                    testUtterance.volume = 0;
                    speechSynthesis.speak(testUtterance);
                    speechSynthesisEnabled = true;
                    console.log("Speech synthesis enabled by user gesture");
                } catch (error) {
                    console.warn("Could not enable speech synthesis:", error);
                }
            }
        }

        // TTS Announcement System (from gridpage)
        async function announceText(textToAnnounce, announcementType = "system") {
            console.log(`ðŸ”Š ANNOUNCE: "${textToAnnounce.substring(0, 50)}..." (Type: ${announcementType})`);
            
            // Initialize audio context if not already done
            if (!audioContextInitialized) {
                console.warn("ðŸ”Š Audio context not initialized - calling enableSpeechSynthesis");
                enableSpeechSynthesis();
            }
            
            return new Promise((resolve, reject) => {
                announcementQueue.push({
                    textToAnnounce,
                    announcementType,
                    resolve,
                    reject
                });
                processAnnouncementQueue();
            });
        }

        // Process announcement queue (from gridpage)
        async function processAnnouncementQueue() {
            if (isAnnouncingNow || announcementQueue.length === 0) {
                console.log(`ðŸ”Š QUEUE: ${isAnnouncingNow ? 'Already announcing' : 'Queue empty'}`);
                return;
            }

            isAnnouncingNow = true;
            const { textToAnnounce, announcementType, resolve, reject } = announcementQueue.shift();

            console.log(`ðŸ”Š QUEUE: Playing "${textToAnnounce.substring(0, 50)}..." (Type: ${announcementType})`);

            try {
                // Fetch audio data from server using authenticatedFetch (like gridpage)
                console.log(`ðŸ”Š Fetching TTS audio from /play-audio...`);
                const response = await authenticatedFetch(`/play-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: textToAnnounce, routing_target: announcementType }),
                });

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => response.text());
                    throw new Error(`Failed to synthesize audio: ${response.status} - ${JSON.stringify(errorBody)}`);
                }

                const jsonResponse = await response.json();
                const audioData = jsonResponse.audio_data;
                const sampleRate = jsonResponse.sample_rate;

                if (!audioData) {
                    throw new Error("No audio data received from server.");
                }

                console.log(`ðŸ”Š Audio data received, sample rate: ${sampleRate}, playing...`);
                const audioDataArrayBuffer = base64ToArrayBuffer(audioData);
                await playAudioToDevice(audioDataArrayBuffer, sampleRate, announcementType);
                
                console.log(`ðŸ”Š Audio playback completed successfully`);
                resolve();

            } catch (error) {
                console.error('ðŸ”Š QUEUE ERROR: Error during announcement playback:', error);
                reject(error);
            } finally {
                isAnnouncingNow = false;
                if (announcementQueue.length > 0) {
                    console.log(`ðŸ”Š QUEUE: Processing next item (${announcementQueue.length} remaining)`);
                    processAnnouncementQueue();
                }
            }
        }

        // Audio utility functions (from gridpage)
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        async function playAudioToDevice(audioDataArrayBuffer, sampleRate, announcementType) {
            try {
                console.log(`ðŸ”Š Creating audio context for playback...`);
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                console.log(`ðŸ”Š Audio context state: ${audioContext.state}`);
                if (audioContext.state === 'suspended') {
                    console.log(`ðŸ”Š Resuming suspended audio context...`);
                    await audioContext.resume();
                    console.log(`ðŸ”Š Audio context resumed, new state: ${audioContext.state}`);
                }

                console.log(`ðŸ”Š Decoding audio data (${audioDataArrayBuffer.byteLength} bytes)...`);
                const audioBuffer = await audioContext.decodeAudioData(audioDataArrayBuffer);
                console.log(`ðŸ”Š Audio decoded: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.numberOfChannels} channels`);
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                
                // Connect to appropriate output (system or personal speaker like gridpage)
                const destination = audioContext.destination;
                source.connect(destination);
                
                console.log(`ðŸ”Š Starting audio playback...`);
                return new Promise((resolve, reject) => {
                    source.onended = () => {
                        console.log(`ðŸ”Š Audio playback ended normally`);
                        resolve();
                    };
                    source.onerror = (error) => {
                        console.error(`ðŸ”Š Audio playback error:`, error);
                        reject(error);
                    };
                    source.start(0);
                });
            } catch (error) {
                console.error('ðŸ”Š Error in playAudioToDevice:', error);
                throw error;
            }
        }

        // --- Custom Button Audio Playback Function ---
        async function playCustomButtonAudio(audioUrl) {
            try {
                console.log(`[AUDIO] Playing custom button audio: ${audioUrl}`);
                
                // Validate URL
                if (!audioUrl || audioUrl.trim() === '') {
                    console.warn('[AUDIO] Empty or null audio URL provided');
                    return;
                }
                
                // Create audio element
                const audio = new Audio(audioUrl);
                
                // Add more detailed event listeners for debugging
                audio.addEventListener('loadstart', () => {
                    console.log('[AUDIO] Started loading audio file');
                });
                
                audio.addEventListener('canplaythrough', () => {
                    console.log('[AUDIO] Audio can play through without buffering');
                });
                
                audio.addEventListener('loadeddata', () => {
                    console.log('[AUDIO] Audio data loaded successfully');
                });
                
                audio.addEventListener('loadedmetadata', () => {
                    console.log(`[AUDIO] Audio metadata loaded - Duration: ${audio.duration}s`);
                });
                
                // Wait for the audio to load and play
                return new Promise((resolve, reject) => {
                    audio.addEventListener('ended', () => {
                        console.log('[AUDIO] Custom audio playback completed');
                        resolve();
                    });
                    
                    audio.addEventListener('error', (e) => {
                        console.error('[AUDIO] Error event triggered:', e);
                        console.error('[AUDIO] Audio error details:', {
                            error: audio.error,
                            networkState: audio.networkState,
                            readyState: audio.readyState
                        });
                        resolve(); // Don't reject, just continue silently
                    });
                    
                    // Start playback
                    console.log('[AUDIO] Attempting to start playback...');
                    audio.play().then(() => {
                        console.log('[AUDIO] Audio.play() promise resolved successfully');
                    }).catch(error => {
                        console.error('[AUDIO] Audio.play() promise rejected:', error);
                        resolve(); // Continue silently on error
                    });
                });
                
            } catch (error) {
                console.error('[AUDIO] Error in playCustomButtonAudio:', error);
                // Don't throw error, just continue silently
            }
        }

        // Build space functionality
        function addToSpeech(text) {
            const currentText = buildSpace.value.trim();
            if (currentText) {
                buildSpace.value = currentText + ' ' + text;
            } else {
                buildSpace.value = text;
            }
            
            console.log('ðŸŽ¯ Recording chat history for tap selection:', text.trim());
            // Record chat history for user selections
            recordChatHistory("", text.trim()).catch(error => {
                console.error('Failed to record chat history for tap selection:', error);
            });
            
            updateSpeechOutput();
        }

        function updateSpeechOutput() {
            // No longer using a separate speech output display
            // The build space textarea shows the current text
        }

        async function speakBuildSpace() {
            let text = buildSpace.value.trim();
            if (text) {
                console.log('Auto Clean enabled?', autoClean);
                
                // If Auto Clean is enabled, clean up the text first
                if (autoClean) {
                    console.log('Auto Clean enabled - cleaning text before speaking');
                    try {
                        const response = await authenticatedFetch('/api/freestyle/cleanup-text', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                text_to_cleanup: text
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            const cleanedText = data.cleaned_text || text;
                            console.log("Original text:", text);
                            console.log("Cleaned text:", cleanedText);
                            
                            // Update the build space with cleaned text
                            text = cleanedText;
                            buildSpace.value = cleanedText;
                        } else {
                            console.error('Failed to cleanup text:', response.statusText);
                        }
                    } catch (error) {
                        console.error('Error during text cleanup:', error);
                        // Continue with original text if cleanup fails
                    }
                }
                
                // Use backend TTS with the (possibly cleaned) text
                await announce(text, "system", true);
            }
        }

        async function clearBuildSpace() {
            const buildSpaceElement = document.getElementById('build-space');
            if (buildSpaceElement) {
                buildSpaceElement.value = '';
                updateSpeechOutput();
                console.log('Build space cleared');
                
                // Reset word options to start fresh after clearing
                await updateFreestyleOptionsWithSelectedWord('');
            } else {
                console.error('Build space element not found - ID: build-space');
            }
        }

        async function backspaceBuildSpace() {
            const buildSpaceElement = document.getElementById('build-space');
            if (buildSpaceElement) {
                const currentText = buildSpaceElement.value.trim();
                if (currentText) {
                    // Split by spaces and remove the last word
                    const words = currentText.split(/\s+/);
                    words.pop(); // Remove last word
                    buildSpaceElement.value = words.join(' ');
                    if (words.length > 0) {
                        buildSpaceElement.value += ' '; // Add trailing space if there are words remaining
                    }
                    updateSpeechOutput();
                    console.log('Last word removed from build space');
                    
                    // Update word options based on remaining text
                    const lastWord = words.length > 0 ? words[words.length - 1] : '';
                    await updateFreestyleOptionsWithSelectedWord(lastWord);
                }
            } else {
                console.error('Build space element not found - ID: build-space');
            }
        }

        // Update build space when user types
        if (buildSpace) {
            buildSpace.addEventListener('input', updateSpeechOutput);
        }

        // Chat History Recording (same as gridpage)
        async function recordChatHistory(question, response) {
            console.log('ðŸŽ¯ recordChatHistory called with:', { question, response });
            try {
                console.log('ðŸŽ¯ Making authenticated fetch call...');
                const recorded = await authenticatedFetch('/record_chat_history', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question, response })
                });
                console.log('ðŸŽ¯ Response received, status:', recorded.status);
                if (!recorded.ok) {
                    const errorText = await recorded.text();
                    console.error('âŒ Chat history server error:', recorded.status, errorText);
                    throw new Error(`HTTP error! status: ${recorded.status} - ${errorText}`);
                }
                const responseData = await recorded.json();
                console.log('âœ… Chat history recorded successfully:', responseData);
            } catch (error) {
                console.error('âŒ Error recording chat history:', error);
            }
        }
        
        // Modified announce function to record chat history for personal messages
        const originalAnnounce = window.announce;
        window.announce = async function(textToAnnounce, announcementType = "system", recordHistory = true) {
            if (originalAnnounce) {
                await originalAnnounce(textToAnnounce, announcementType, recordHistory);
            }
            
            // Record chat history for personal announcements (user selections)
            if (recordHistory && announcementType === "personal" && textToAnnounce && textToAnnounce.trim()) {
                recordChatHistory("", textToAnnounce.trim()).catch(error => {
                    console.error('Failed to record chat history for announcement:', error);
                });
            }
        };

        function promptForFreestyleWord() {
            const word = prompt('Enter a word or phrase:');
            if (word && word.trim()) {
                addToSpeech(word.trim());
            }
        }

        // Wake Word Detection and Speech Recognition Functions
        async function setupWakeWordDetection() {
            // Settings are now loaded in loadUserSettings, just start speech recognition
            setupSpeechRecognition();
        }

        function setupSpeechRecognition() {
            if (isSettingUpRecognition || recognition) {
                return;
            }
            
            isSettingUpRecognition = true;
            console.log("Setting up wake word speech recognition...");
            
            const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognitionAPI) {
                console.error("Speech Recognition API not supported.");
                isSettingUpRecognition = false;
                return;
            }
            
            recognition = new SpeechRecognitionAPI();
            recognition.continuous = true;
            recognition.interimResults = false;
            console.log("Wake word recognition object created:", recognition);

            recognition.onerror = function(event) {
                console.error("Wake word speech recognition error:", event.error, event.message);
                if (['no-speech', 'audio-capture', 'network'].includes(event.error) && !listeningForQuestion) {
                    console.log("Wake word recognition error, attempting restart...");
                    setTimeout(() => {
                        recognition = null;
                        isSettingUpRecognition = false;
                        setupSpeechRecognition();
                    }, 1000);
                } else {
                    isSettingUpRecognition = false;
                    recognition = null;
                }
            };

            recognition.onresult = async (event) => {
                const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
                console.log('Wake word check - Speech recognized:', transcript);
                
                if (listeningForQuestion) {
                    console.log("Ignoring wake word, currently listening for question.");
                    return;
                }

                const interjectionToUse = wakeWordInterjection || "hey";
                const nameToUse = wakeWordName || "bravo";
                const phraseWithSpace = `${interjectionToUse} ${nameToUse}`;
                const phraseWithComma = `${interjectionToUse}, ${nameToUse}`;
                const phraseWithCommaNoSpace = `${interjectionToUse},${nameToUse}`;

                console.log(`Checking for: "${phraseWithSpace}" OR "${phraseWithComma}" OR "${phraseWithCommaNoSpace}"`);

                if (transcript.includes(phraseWithSpace) || transcript.includes(phraseWithComma) || transcript.includes(phraseWithCommaNoSpace)) {
                    console.log(`Wake word detected! ("${transcript}")`);
                    
                    if (recognition) {
                        console.log("Stopping wake word recognition...");
                        try {
                            recognition.stop();
                        } catch (e) {
                            console.warn("Error stopping wake word recognition:", e);
                        }
                        recognition.onresult = null;
                        recognition.onerror = null;
                        recognition.onend = null;
                        recognition = null;
                        console.log("Stopped and cleared wake word recognition instance.");
                    }
                    isSettingUpRecognition = false;

                    // Highlight question textarea
                    updateStatusMessage("Listening for your question...");
                    if (questionDisplay) {
                        questionDisplay.classList.add(LISTENING_HIGHLIGHT_CLASS);
                        questionDisplay.placeholder = "I'm listening for your question...";
                    }

                    // Announce and start listening for question
                    const announcement = "Listening for your question...";
                    console.log("Calling announce for wake word response...");
                    try {
                        await announce(announcement, "system", false);
                        console.log("Announce finished. Setting up question recognition.");
                        setupQuestionRecognition();
                    } catch (announceError) {
                        console.error("Error during announcement:", announceError);
                        if (questionDisplay) {
                            questionDisplay.classList.remove(LISTENING_HIGHLIGHT_CLASS);
                        }
                        setupSpeechRecognition(); // Restart wake word detection
                    }
                }
            };

            recognition.onend = () => {
                console.log("Wake word recognition ended.");
                if (!listeningForQuestion && !isSettingUpRecognition && recognition) {
                    console.log("Wake word recognition ended unexpectedly, restarting.");
                    recognition = null;
                    setTimeout(setupSpeechRecognition, 500);
                } else {
                    console.log("Wake word recognition ended normally or was already being reset/stopped.");
                    isSettingUpRecognition = false;
                }
            };

            try {
                recognition.start();
                console.log("Wake word recognition started.");
                isSettingUpRecognition = false;
            } catch (e) {
                console.error("Error starting wake word recognition:", e);
                isSettingUpRecognition = false;
                recognition = null;
            }
        }

        function setupQuestionRecognition() {
            console.log("Attempting to set up question recognition...");
            const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognitionAPI) {
                console.error("Speech Recognition API not supported.");
                announce("Sorry, I can't use speech recognition.", "system", false);
                return;
            }

            questionRecognitionInstance = new SpeechRecognitionAPI();
            questionRecognitionInstance.lang = 'en-US';
            questionRecognitionInstance.continuous = false;
            questionRecognitionInstance.interimResults = true;
            questionRecognitionInstance.maxAlternatives = 1;

            let finalTranscript = '';
            let listeningTimeout;
            let hasProcessedResult = false;
            let isRestartingKeyword = false;

            console.log("Question Recognition Config:", {
                continuous: false,
                interimResults: true,
                lang: 'en-US',
                maxAlternatives: 1
            });

            questionRecognitionInstance.onstart = () => {
                console.log("===== QUESTION RECOGNITION: Listening started =====");
                finalTranscript = '';
                hasProcessedResult = false;
                
                updateStatusMessage("Listening for question...");
                if (questionDisplay) {
                    questionDisplay.placeholder = "Listening...";
                    questionDisplay.value = "";
                    questionDisplay.classList.add(LISTENING_HIGHLIGHT_CLASS);
                    console.log("Question display updated: highlighted and cleared");
                }
                listeningForQuestion = true;
                console.log("listeningForQuestion set to TRUE");
                clearTimeout(listeningTimeout);
                listeningTimeout = setTimeout(() => {
                    if (listeningForQuestion && !finalTranscript && !hasProcessedResult) {
                        console.log("===== QUESTION TIMEOUT: No speech detected =====");
                        announce("I didn't hear anything. Try again?", "system", false);
                        try {
                            questionRecognitionInstance.stop();
                        } catch (e) {}
                    }
                }, 10000);
                console.log("Question recognition timeout set for 10 seconds");
            };

            questionRecognitionInstance.onresult = async (event) => {
                console.log("===== QUESTION ONRESULT: Speech detected =====");
                if (hasProcessedResult) {
                    console.log("Result already processed, ignoring");
                    return;
                }
                clearTimeout(listeningTimeout);
                
                let interimTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    const transcriptPart = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcriptPart;
                    } else {
                        interimTranscript += transcriptPart;
                    }
                }
                
                const isFinishedUtterance = event.results[event.results.length - 1].isFinal;
                console.log("===== QUESTION TRANSCRIPT =====");
                console.log("Interim:", interimTranscript);
                console.log("Final so far:", finalTranscript);
                console.log("Is final utterance:", isFinishedUtterance);
                
                // Update display with current transcript
                if (questionDisplay) {
                    questionDisplay.value = finalTranscript + (interimTranscript || '');
                }

                if (isFinishedUtterance && finalTranscript.trim()) {
                    hasProcessedResult = true;
                    console.log("Final Question:", finalTranscript.trim().toLowerCase());
                    listeningForQuestion = false;

                    // Remove highlight and process question
                    if (questionDisplay) {
                        questionDisplay.classList.remove(LISTENING_HIGHLIGHT_CLASS);
                        questionDisplay.value = finalTranscript.trim();
                    }

                    try {
                        announce("Okay, processing: " + finalTranscript.trim() + ". Give me a moment.", "system", false);
                        currentQuestion = finalTranscript.trim().toLowerCase();
                        
                        // Update status message with current question
                        updateStatusMessage(`Current: ${currentQuestion}`);

                        // Process the question and update the interface
                        await processQuestionAndUpdateInterface(currentQuestion);
                        
                    } catch (error) {
                        console.error('Error processing question:', error);
                        announce("Error processing question.", "system", false);
                        isRestartingKeyword = true;
                        setupSpeechRecognition();
                    } finally {
                        updateStatusMessage("Ready - Say 'Hey Bravo' to start");
                        if (questionDisplay) {
                            questionDisplay.placeholder = "Say 'Hey Bravo' followed by your question...";
                        }
                        console.log("Question processing finished.");
                    }
                } else if (!isFinishedUtterance) {
                    console.log("Waiting for final result...");
                } else {
                    console.log("Final utterance empty.");
                    listeningForQuestion = false;
                    if (questionDisplay) {
                        questionDisplay.classList.remove(LISTENING_HIGHLIGHT_CLASS);
                    }
                }
            };

            questionRecognitionInstance.onerror = (event) => {
                clearTimeout(listeningTimeout);
                if (hasProcessedResult) return;
                
                console.error("Question Error:", event.error, event.message);
                let errorMessage = "Speech recognition error.";
                let attemptRetry = false;
                
                if (event.error === 'no-speech') {
                    errorMessage = "Didn't hear anything. Try again?";
                    if (!questionRecognitionInstance.hasRetried) {
                        attemptRetry = true;
                        errorMessage += " Retrying...";
                        questionRecognitionInstance.hasRetried = true;
                    } else {
                        console.log("Already retried.");
                    }
                } else if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    errorMessage = "Mic access denied.";
                } else if (event.error === 'audio-capture') {
                    errorMessage = "Mic problem.";
                } else if (event.error === 'network') {
                    errorMessage = "Network error.";
                } else if (event.error === 'aborted') {
                    errorMessage = "";
                }

                if (errorMessage) {
                    announce(errorMessage, "system", false);
                }
                
                updateStatusMessage("Ready - Say 'Hey Bravo' to start");
                if (questionDisplay) {
                    questionDisplay.placeholder = "Say 'Hey Bravo' followed by your question...";
                    questionDisplay.classList.remove(LISTENING_HIGHLIGHT_CLASS);
                }
                listeningForQuestion = false;
                try {
                    questionRecognitionInstance.stop();
                } catch (e) {}

                if (attemptRetry) {
                    setTimeout(() => {
                        if (!hasProcessedResult && !listeningForQuestion) {
                            setupQuestionRecognition();
                        }
                    }, 1500);
                } else {
                    isRestartingKeyword = true;
                    setupSpeechRecognition();
                }
            };

            questionRecognitionInstance.onend = () => {
                console.log("Question Recognition ended.");
                listeningForQuestion = false;
                clearTimeout(listeningTimeout);
                
                if (questionDisplay) {
                    questionDisplay.classList.remove(LISTENING_HIGHLIGHT_CLASS);
                }
                
                if (!hasProcessedResult && !isRestartingKeyword) {
                    console.log("Question rec ended (no result), restarting wake word detection.");
                    setupSpeechRecognition();
                } else {
                    console.log("Not restarting wake word listener from onend (processed, retrying, or handled by error).");
                }
                
                questionRecognitionInstance = null;
                console.log("Question instance cleaned up.");
            };

            setTimeout(() => {
                try {
                    console.log("Calling start() for question recognition...");
                    questionRecognitionInstance.start();
                } catch (e) {
                    console.error("Start error:", e);
                    announce("Couldn't start listening.", "system", false);
                    listeningForQuestion = false;
                    clearTimeout(listeningTimeout);
                    isRestartingKeyword = true;
                    setupSpeechRecognition();
                }
            }, 150);
        }

        async function processQuestionAndUpdateInterface(question) {
            console.log("Processing question and updating interface:", question);
            
            try {
                // Use the question as a category context for generating options
                const questionCategory = {
                    label: question,
                    llm_prompt: `Generate response options for the question: "${question}". Provide helpful answers, suggestions, or related communication phrases.`
                };

                // Update both gridpage-style options (top 2 rows) and freestyle options (bottom 3 rows)
                console.log("Generating gridpage-style options for question...");
                const gridpageOptions = await generateGridpageLLMOptions(questionCategory.llm_prompt, 18);
                renderCategoryOptions(gridpageOptions);
                
                console.log("Generating freestyle options for question...");
                const freestyleOptions = await generateFreestyleLLMOptions(questionCategory, 29);
                renderFreestyleOptions(freestyleOptions);
                
                // Set the current category to the question for context
                currentCategory = questionCategory;
                
                console.log("Interface updated with question-based options");
                
            } catch (error) {
                console.error('Error updating interface with question:', error);
                announce("Sorry, I had trouble processing that question.", "system", false);
            }
        }

        // Proper announcement system (from gridpage)
        async function announce(textToAnnounce, announcementType = "system", recordHistory = true) {
            console.log(`ðŸ”Š ANNOUNCE: "${textToAnnounce.substring(0, 50)}..." (Type: ${announcementType})`);
            
            // Initialize audio context if not already done
            if (!audioContextInitialized) {
                console.warn("ðŸ”Š Audio context not initialized - calling enableSpeechSynthesis");
                enableSpeechSynthesis();
            }
            
            return new Promise((resolve, reject) => {
                announcementQueue.push({
                    textToAnnounce,
                    announcementType,
                    resolve,
                    reject
                });
                processAnnouncementQueue();
            });
        }

        // Initialize on page load
        // Initialize mood selection if enabled
        async function checkAndShowMoodSelection() {
            try {
                // Check if mood selection is enabled and not already shown this session
                const existingMood = sessionStorage.getItem('currentSessionMood');
                if (!existingMood || existingMood === '') {
                    // Check if showMoodSelection function is available
                    if (typeof showMoodSelection === 'function') {
                        showMoodSelection((selectedMood) => {
                            console.log('Mood selected on tap interface:', selectedMood);
                            // Continue with normal page flow after mood selection
                        });
                    }
                }
            } catch (error) {
                console.error('Error checking mood selection:', error);
            }
        }

        // Show mood selection after page is ready
        setTimeout(() => {
            checkAndShowMoodSelection();
        }, 1000); // Delay to ensure mood-selection.js is loaded

        // (Initialization is now handled by DOMContentLoaded event listener above)
    </script>
    
    <!-- Add mood selection functionality -->
    <script src="/static/mood-selection.js"></script>

    <!-- Admin Toolbar JavaScript -->
    <script>
        // Admin toolbar functionality
        const lockButton = document.getElementById('lock-icon');
        const adminIconElements = document.querySelectorAll('.admin-icon');
        const lockToolbarButton = document.getElementById('lock-toolbar-button');
        const pinModal = document.getElementById('pin-modal');
        const pinInput = document.getElementById('pin-input');
        const pinSubmitButton = document.getElementById('pin-submit');
        const pinCancelButton = document.getElementById('pin-cancel');
        const pinError = document.getElementById('pin-error');
        const switchUserButton = document.getElementById('switch-user-button');
        const logoutButton = document.getElementById('logout-button');

        // Function to show PIN modal
        function showPinModal() {
            if (pinModal) {
                pinModal.classList.remove('hidden');
                if (pinInput) {
                    pinInput.value = '';
                    pinInput.focus();
                }
                if (pinError) {
                    pinError.classList.add('hidden');
                }
            }
        }

        // Function to hide PIN modal
        function hidePinModal() {
            if (pinModal) {
                pinModal.classList.add('hidden');
            }
            if (pinInput) {
                pinInput.value = '';
            }
            if (pinError) {
                pinError.classList.add('hidden');
            }
        }

        // Function to validate PIN with backend
        async function validatePin(pin) {
            try {
                const response = await authenticatedFetch('/api/account/toolbar-pin', {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data.pin === pin;
                }
            } catch (error) {
                console.error('Error validating PIN:', error);
            }
            return false;
        }

        // Function to unlock admin toolbar
        function unlockToolbar() {
            adminIconElements.forEach(icon => {
                icon.classList.remove('hidden');
            });
            if (lockToolbarButton) {
                lockToolbarButton.classList.remove('hidden');
            }
            if (lockButton) {
                lockButton.style.display = 'none';
            }
            hidePinModal();
        }

        // Function to lock admin toolbar
        function lockToolbar() {
            adminIconElements.forEach(icon => {
                icon.classList.add('hidden');
            });
            if (lockToolbarButton) {
                lockToolbarButton.classList.add('hidden');
            }
            if (lockButton) {
                lockButton.style.display = 'block';
            }
        }

        // Event listener for lock button
        if (lockButton) {
            lockButton.addEventListener('click', showPinModal);
        }

        // Event listener for lock toolbar button (locks the toolbar back)
        if (lockToolbarButton) {
            lockToolbarButton.addEventListener('click', lockToolbar);
        }

        // Event listener for PIN submit
        if (pinSubmitButton) {
            pinSubmitButton.addEventListener('click', async () => {
                const pin = pinInput.value;
                if (pin.length >= 3 && pin.length <= 10) {
                    const isValid = await validatePin(pin);
                    if (isValid) {
                        unlockToolbar();
                    } else {
                        if (pinError) {
                            pinError.textContent = 'Invalid PIN. Please try again.';
                            pinError.classList.remove('hidden');
                        }
                        if (pinInput) {
                            pinInput.value = '';
                            pinInput.focus();
                        }
                    }
                } else {
                    if (pinError) {
                        pinError.textContent = 'PIN must be 3-10 characters.';
                        pinError.classList.remove('hidden');
                    }
                }
            });
        }

        // Event listener for PIN cancel
        if (pinCancelButton) {
            pinCancelButton.addEventListener('click', hidePinModal);
        }

        // Event listener for Enter key in PIN input
        if (pinInput) {
            pinInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    if (pinSubmitButton) {
                        pinSubmitButton.click();
                    }
                }
            });
        }

        // Switch user functionality
        if (switchUserButton) {
            switchUserButton.addEventListener('click', () => {
                // Clear session and redirect to auth page for user selection
                sessionStorage.removeItem('currentAacUserId');
                window.location.href = 'auth.html';
            });
        }

        // Logout functionality
        if (logoutButton) {
            logoutButton.addEventListener('click', () => {
                // Clear all session storage and redirect to auth page
                sessionStorage.clear();
                window.location.href = 'auth.html';
            });
        }

        // Avatar manager functionality removed

        // Close PIN modal when clicking outside
        if (pinModal) {
            pinModal.addEventListener('click', (e) => {
                if (e.target === pinModal) {
                    hidePinModal();
                }
            });
        }

        // Close PIN modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && pinModal && !pinModal.classList.contains('hidden')) {
                hidePinModal();
            }
        });

        // Dynamic Home navigation function
        async function navigateToHome() {
            try {
                const response = await authenticatedFetch('/api/interface-preference', {
                    method: 'GET',
                    credentials: 'include'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.useTapInterface) {
                        window.location.href = 'tap_interface.html';
                    } else {
                        window.location.href = 'gridpage.html?page=home';
                    }
                } else {
                    // Fallback to gridpage if can't determine preference
                    window.location.href = 'gridpage.html?page=home';
                }
            } catch (error) {
                console.error('Error determining interface preference:', error);
                // Fallback to gridpage
                window.location.href = 'gridpage.html?page=home';
            }
        }

        // Make navigateToHome available globally for admin pages
        window.navigateToHome = navigateToHome;

        // Scheduled Favorites Logic
        (function() {
            let scheduledFavoriteToLoad = null;

            async function checkScheduledFavorites() {
                console.log("Checking for scheduled favorites...");
                try {
                    // Wait for authenticatedFetch to be available if it's not yet
                    if (typeof authenticatedFetch !== 'function') {
                        console.log("authenticatedFetch not ready, retrying in 1s...");
                        setTimeout(checkScheduledFavorites, 1000);
                        return;
                    }

                    // Wait for user tokens to be initialized
                    if (!firebaseIdToken || !currentAacUserId) {
                        // Check if they exist in storage (user is logged in but context not fully initialized)
                        const storedToken = sessionStorage.getItem(FIREBASE_TOKEN_SESSION_KEY);
                        const storedUser = sessionStorage.getItem(AAC_USER_ID_SESSION_KEY);
                        
                        if (storedToken && storedUser) {
                            console.log("User tokens found in storage, waiting for initialization...");
                            setTimeout(checkScheduledFavorites, 500);
                            return;
                        } else {
                            console.log("No user tokens found, skipping schedule check.");
                            return;
                        }
                    }

                    // Fetch current state to see if already loaded
                    let currentFavoriteName = null;
                    let currentLoadedAt = null;
                    try {
                        const stateResponse = await authenticatedFetch('/get-user-current');
                        if (stateResponse.ok) {
                            const stateData = await stateResponse.json();
                            currentFavoriteName = stateData.favorite_name;
                            currentLoadedAt = stateData.loaded_at;
                        }
                    } catch (e) {
                        console.warn("Could not fetch current state:", e);
                    }

                    const response = await authenticatedFetch('/api/user-current-favorites');
                    if (!response.ok) return;
                    
                    const data = await response.json();
                    const favorites = data.favorites;
                    
                    const now = new Date();
                    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const currentDay = days[now.getDay()];
                    const currentHour = now.getHours();
                    const currentMinute = now.getMinutes();
                    const currentTime = currentHour * 60 + currentMinute;
                    
                    console.log(`Current time: ${currentDay} ${currentHour}:${currentMinute} (${currentTime})`);
                    console.log(`Current loaded favorite: ${currentFavoriteName}, Loaded at: ${currentLoadedAt}`);

                    for (const favorite of favorites) {
                        if (favorite.schedule && favorite.schedule.enabled) {
                            // Check if current day is in the scheduled days list
                            // Handle both new list format and old single string format
                            let isDayMatch = false;
                            if (favorite.schedule.days_of_week && Array.isArray(favorite.schedule.days_of_week)) {
                                isDayMatch = favorite.schedule.days_of_week.includes(currentDay);
                            } else if (favorite.schedule.day_of_week) {
                                isDayMatch = favorite.schedule.day_of_week === currentDay;
                            }

                            if (isDayMatch) {
                                const [startHour, startMinute] = favorite.schedule.start_time.split(':').map(Number);
                                const [endHour, endMinute] = favorite.schedule.end_time.split(':').map(Number);
                                
                                const startTime = startHour * 60 + startMinute;
                                const endTime = endHour * 60 + endMinute;
                                
                                if (currentTime >= startTime && currentTime <= endTime) {
                                    // Check if we've already handled this schedule in this session
                                    const sessionKey = `bravo_schedule_handled_${favorite.name}_${currentDay}`;
                                    if (sessionStorage.getItem(sessionKey)) {
                                        console.log(`Scheduled favorite ${favorite.name} already handled in this session. Skipping.`);
                                        continue;
                                    }

                                    // Check if already loaded RECENTLY (Server-side check as fallback)
                                    if (currentFavoriteName === favorite.name) {
                                        if (currentLoadedAt) {
                                            const loadedDate = new Date(currentLoadedAt);
                                            const scheduleStartDate = new Date();
                                            scheduleStartDate.setHours(startHour, startMinute, 0, 0);
                                            
                                            // If loaded after the schedule started today, AND we are in a fresh session (handled check passed),
                                            // we might still want to prompt if the user explicitly logged in again.
                                            // But to be safe, if the DB says we are already there and fresh, we can skip.
                                            // However, the user reported "not seeing prompt on login".
                                            // So we will RELAX this check. If session is fresh, we prompt even if DB says fresh.
                                            // This allows the user to "confirm" their location on login.
                                            
                                            // console.log(`Scheduled favorite ${favorite.name} is active. Session is fresh. Prompting to confirm.`);
                                        }
                                    }

                                    const key = getScheduleKey(favorite);
                                    if (ignoredSchedules.has(key)) continue;

                                    // Check if modal is already open
                                    const modal = document.getElementById('scheduledFavoriteModal');
                                    if (modal && modal.style.display !== 'none') return;

                                    console.log(`Found matching scheduled favorite: ${favorite.name}`);
                                    
                                    scheduledFavoriteToLoad = favorite;
                                    showScheduledFavoriteModal(favorite);
                                    return; // Only show one prompt at a time
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error checking scheduled favorites:', error);
                }
            }

            function showScheduledFavoriteModal(favorite) {
                const modal = document.getElementById('scheduledFavoriteModal');
                const message = document.getElementById('scheduledFavoriteMessage');
                if (modal && message) {
                    message.textContent = `It looks like you are at ${favorite.name}. Would you like to load this location?`;
                    modal.style.display = 'flex';
                }
            }

            function hideScheduledFavoriteModal() {
                const modal = document.getElementById('scheduledFavoriteModal');
                if (modal) modal.style.display = 'none';
            }

            function getScheduleKey(favorite) {
                const now = new Date();
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const currentDay = days[now.getDay()];
                return `${favorite.name}-${currentDay}-${favorite.schedule.start_time}`;
            }

            // Track ignored favorites
            const ignoredSchedules = new Set();

            function handleIgnore() {
                if (scheduledFavoriteToLoad) {
                    ignoredSchedules.add(getScheduleKey(scheduledFavoriteToLoad));
                    
                    // Mark as handled in session
                    const now = new Date();
                    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    const currentDay = days[now.getDay()];
                    const sessionKey = `bravo_schedule_handled_${scheduledFavoriteToLoad.name}_${currentDay}`;
                    sessionStorage.setItem(sessionKey, 'true');
                }
                hideScheduledFavoriteModal();
            }

            async function loadScheduledFavorite() {
                if (!scheduledFavoriteToLoad) return;
                
                // Mark as handled in session BEFORE reload
                const now = new Date();
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const currentDay = days[now.getDay()];
                const sessionKey = `bravo_schedule_handled_${scheduledFavoriteToLoad.name}_${currentDay}`;
                sessionStorage.setItem(sessionKey, 'true');
                
                hideScheduledFavoriteModal();
                
                try {
                    // Load the favorite data
                    const loadTimestamp = new Date().toISOString();
                    const saveData = {
                        location: scheduledFavoriteToLoad.location || '',
                        people: scheduledFavoriteToLoad.people || '',
                        activity: scheduledFavoriteToLoad.activity || '',
                        loaded_at: loadTimestamp,
                        favorite_name: scheduledFavoriteToLoad.name,
                        saved_at: loadTimestamp
                    };
                    
                    const response = await authenticatedFetch('/user_current', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(saveData)
                    });
                    
                    if (response.ok) {
                        console.log(`Loaded scheduled favorite: ${scheduledFavoriteToLoad.name}`);
                        window.location.reload();
                    }
                } catch (error) {
                    console.error('Error loading scheduled favorite:', error);
                }
            }

            function init() {
                const ignoreBtn = document.getElementById('ignoreScheduledFavorite');
                const loadBtn = document.getElementById('loadScheduledFavorite');
                
                if (ignoreBtn) {
                    ignoreBtn.removeEventListener('click', hideScheduledFavoriteModal);
                    ignoreBtn.addEventListener('click', handleIgnore);
                }
                if (loadBtn) {
                    loadBtn.removeEventListener('click', loadScheduledFavorite);
                    loadBtn.addEventListener('click', loadScheduledFavorite);
                }

                // Initial check with delay to allow auth to settle
                console.log("Scheduling initial favorites check in 2s...");
                setTimeout(checkScheduledFavorites, 2000);
                // Periodic check
                setInterval(checkScheduledFavorites, 60000);
            }

            // Event Listeners
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
            
        })();
    </script>

    <!-- Spelling Modal -->
    <div id="spelling-modal" class="modal-overlay hidden" style="display: none;">
        <div class="modal-content">
            <div class="spell-modal-banner">
                <h3><i class="fas fa-spell-check"></i> Spell a Word</h3>
            </div>
            
            <div class="spelling-content">
                <!-- Current Word Section -->
                <div class="spell-section">
                    <h4 class="spell-section-header">
                        <i class="fas fa-keyboard"></i> Current Word
                    </h4>
                    <div class="current-word-section">
                        <input type="text" id="current-word" class="current-word-input" readonly>
                        <div class="word-controls">
                            <button id="add-word-btn" class="word-control-btn add-btn">
                                <i class="fas fa-plus"></i> OK
                            </button>
                            <button id="clear-word-btn" class="word-control-btn clear-btn">
                                <i class="fas fa-backspace"></i> Clear
                            </button>
                            <button id="backspace-btn" class="word-control-btn backspace-btn">
                                <i class="fas fa-arrow-left"></i> Backspace
                            </button>
                            <button id="cancel-spelling-btn" class="word-control-btn close-btn">
                                <i class="fas fa-times"></i> Cancel
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Word Predictions Section -->
                <div class="spell-section predictions-section">
                    <h4 class="spell-section-header">
                        <i class="fas fa-lightbulb"></i> Suggested Words
                    </h4>
                    <div id="word-predictions" class="word-predictions-grid">
                        <!-- Word predictions will be generated here -->
                    </div>
                </div>

                <!-- Alphabet Grid Section -->
                <div class="spell-section alphabet-section">
                    <h4 class="spell-section-header">
                        <i class="fas fa-font"></i> Letters
                    </h4>
                    <div id="alphabet-grid" class="alphabet-grid">
                        <!-- Alphabet buttons will be generated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scheduled Favorite Prompt Modal -->
    <div id="scheduledFavoriteModal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px; text-align: center;">
            <div class="modal-header" style="justify-content: center; border-bottom: none;">
                <h3 class="modal-title">Scheduled Location Found</h3>
            </div>
            <p id="scheduledFavoriteMessage" style="margin-bottom: 20px; font-size: 1.1em; color: #555;">
                It looks like you are at [Location Name]. Would you like to load this location?
            </p>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button id="ignoreScheduledFavorite" class="clear-btn" style="background: #ccc; color: #333; font-size: 1em; padding: 10px 20px;">
                    No
                </button>
                <button id="loadScheduledFavorite" class="speak-btn" style="font-size: 1em; padding: 10px 20px;">
                    Yes, Load It
                </button>
            </div>
        </div>
    </div>
</body>
</html>