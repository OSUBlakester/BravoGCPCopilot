<!DOCTYPE html>
<html>
<head>
    <title>Games</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="/static/splash-screen.css">
    <style>
        /* --- Basic Body Style --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
        }

        /* --- Admin Toolbar Styles --- */
        .admin-toolbar {
            background-color: #ffffff;
            padding: 0.25rem 0.5rem;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .admin-toolbar button {
            padding: 0.25rem 0.5rem;
            border: 1px solid #ccc;
            background-color: #f8f9fa;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .admin-toolbar button:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }

        /* --- Page Banner Styles --- */
        .page-banner {
            background-color: #002244;
            color: #FB4F14;
            padding: 0.75em 1.5em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .page-banner h1 {
            margin: 0;
            font-size: 1.75em;
            font-weight: 500;
            text-align: left;
        }

        /* --- Game Container Styles --- */
        .game-container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 1rem;
        }

        /* --- Game Menu Styles --- */
        .game-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .game-card {
            background: white;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .game-card:hover {
            border-color: #FB4F14;
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
        }

        .game-card i {
            font-size: 3rem;
            color: #FB4F14;
            margin-bottom: 1rem;
        }

        .game-card h3 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #002244;
        }

        .game-card p {
            color: #666;
            line-height: 1.5;
        }

        /* --- Game Grid Styles --- */
        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .game-button {
            background: white;
            border: 3px solid #ddd;
            border-radius: 1rem;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            font-weight: 500;
            color: #002244;
        }

        .game-button:hover {
            border-color: #FB4F14;
            background-color: #fff5f3;
            transform: translateY(-2px);
        }

        .game-button.selected {
            border-color: #FB4F14;
            background-color: #FB4F14;
            color: white;
        }

        .game-button.scanning {
            border-color: #fbbf24;
            background-color: #fef3c7;
            animation: pulse 1s infinite;
        }

        /* Make sure action buttons in actionButtons container also get scanning styles */
        #actionButtons .game-button.scanning {
            border-color: #fbbf24;
            background-color: #fef3c7;
            animation: pulse 1s infinite;
        }

        .game-button i {
            display: block;
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: inherit;
        }

        /* --- Game Status Styles --- */
        .game-status {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .game-status h2 {
            color: #002244;
            margin-bottom: 1rem;
        }

        .game-status .status-text {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 1rem;
        }

        .game-status .counter {
            font-size: 1.5rem;
            font-weight: bold;
            color: #FB4F14;
        }

        /* --- Question History Styles --- */
        .question-history {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .question-history h3 {
            color: #002244;
            margin-bottom: 1rem;
        }

        #qaList {
            max-height: 150px;
            height: 150px;
            overflow-y: auto;
            padding: 0.5rem;
            border: 1px solid #eee;
            border-radius: 0.5rem;
            background-color: #fafafa;
        }

        .qa-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid #eee;
        }

        .qa-item:last-child {
            border-bottom: none;
        }

        .qa-question {
            font-weight: 500;
            color: #002244;
        }

        .qa-answer {
            color: #FB4F14;
            font-weight: bold;
        }

        /* --- Action Buttons now use game-button styling --- */

        /* --- Back Button --- */
        .back-button {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: #002244;
            color: white;
            border: none;
            border-radius: 50px;
            padding: 1rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }

        .back-button:hover {
            background: #1e3a8a;
            transform: translateY(-2px);
        }

        /* --- Listening Indicator --- */
        .listening-indicator {
            background: #22c55e;
            color: white;
            border-radius: 1rem;
            padding: 1rem;
            text-align: center;
            margin: 1rem 0;
            animation: pulse 2s infinite;
        }

        /* --- Loading States --- */
        .loading {
            text-align: center;
            padding: 2rem;
        }

        .loading i {
            font-size: 3rem;
            color: #FB4F14;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* --- Hidden State --- */
        .hidden {
            display: none !important;
        }

        /* --- Error States --- */
        .error-state {
            background: #fee2e2;
            border: 2px solid #fca5a5;
            border-radius: 1rem;
            padding: 1.5rem;
            text-align: center;
            margin: 1rem 0;
        }

        .error-state i {
            font-size: 2rem;
            color: #dc2626;
            margin-bottom: 1rem;
        }

        .error-state h3 {
            color: #dc2626;
            margin-bottom: 0.5rem;
        }

        .error-state p {
            color: #7f1d1d;
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splashScreen" class="splash-screen">
        <div class="splash-content">
            <i class="fas fa-gamepad" style="font-size: 4rem; color: #FB4F14; margin-bottom: 1rem;"></i>
            <h2>Loading Games...</h2>
        </div>
    </div>

    <!-- Page Banner -->
    <div class="page-banner">
        <h1>ðŸŽ® Games</h1>
        <div class="admin-toolbar">
            <!-- Admin toolbar content can be added here -->
        </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent" class="game-container">
        
        <!-- Game Menu (Initial View) -->
        <div id="gameMenu" class="game-menu">
            <div class="game-card" onclick="startTwentyQuestions()">
                <i class="fas fa-question-circle"></i>
                <h3>20 Questions</h3>
                <p>Play the classic guessing game! One player thinks of something and the other tries to guess it by asking yes or no questions.</p>
            </div>
            
            <!-- Future games can be added here -->
            <div class="game-card" style="opacity: 0.5; cursor: not-allowed;">
                <i class="fas fa-puzzle-piece"></i>
                <h3>More Games</h3>
                <p>Additional games coming soon! Stay tuned for more fun activities.</p>
            </div>
        </div>

        <!-- 20 Questions Game View -->
        <div id="twentyQuestionsGame" class="hidden">
            
            <!-- Game Status -->
            <div id="gameStatus" class="game-status">
                <h2 id="gameTitle">20 Questions</h2>
                <div id="statusText" class="status-text">Choose how you want to play!</div>
                <div id="gameCounter" class="counter"></div>
            </div>

            <!-- Role Selection -->
            <div id="roleSelection" class="game-grid">
                <div class="game-button" onclick="selectRole('ask')">
                    <i class="fas fa-user-friends"></i>
                    I ask the questions
                </div>
                <div class="game-button" onclick="selectRole('answer')">
                    <i class="fas fa-lightbulb"></i>
                    They ask the questions
                </div>
            </div>

            <!-- Category Selection -->
            <div id="categorySelection" class="game-grid hidden">
                <div class="game-button" onclick="selectCategory('person')">
                    <i class="fas fa-user"></i>
                    Person
                </div>
                <div class="game-button" onclick="selectCategory('place')">
                    <i class="fas fa-map-marker-alt"></i>
                    Place
                </div>
                <div class="game-button" onclick="selectCategory('thing')">
                    <i class="fas fa-cube"></i>
                    Thing
                </div>
            </div>

            <!-- Options Selection (for questions, guesses, or P/P/T options) -->
            <div id="optionsSelection" class="game-grid hidden">
                <!-- Options will be populated dynamically -->
            </div>

            <!-- Response Options (for Player 1 to choose their response) -->
            <div id="responseOptions" class="game-grid hidden">
                <!-- Response options will be populated dynamically -->
            </div>

            <!-- Question History -->
            <div id="questionHistory" class="question-history hidden">
                <h3>Questions Asked:</h3>
                <div id="qaList">
                    <!-- Q&A pairs will be added here -->
                </div>
            </div>

            <!-- Listening Indicator -->
            <div id="listeningIndicator" class="listening-indicator hidden">
                <i class="fas fa-microphone"></i>
                <div>Listening...</div>
            </div>

            <!-- Loading State -->
            <div id="loadingState" class="loading hidden">
                <i class="fas fa-spinner"></i>
                <div>Generating options...</div>
            </div>

            <!-- Error State -->
            <div id="errorState" class="error-state hidden">
                <i class="fas fa-exclamation-triangle"></i>
                <h3>Oops!</h3>
                <p id="errorMessage">Something went wrong. Please try again.</p>
            </div>

            <!-- Action Buttons -->
            <div id="actionButtons" class="game-grid hidden">
                <div id="askAnotherBtn" class="game-button" onclick="askAnother()">
                    <i class="fas fa-question-circle"></i>
                    Ask Another Question
                </div>
                <div id="makeGuessBtn" class="game-button" onclick="makeGuess()">
                    <i class="fas fa-lightbulb"></i>
                    Make a Guess
                </div>
                <div class="game-button" style="background-color: #dc2626; color: white;" onclick="exitGame()">
                    <i class="fas fa-times"></i>
                    Exit Game
                </div>
            </div>
        </div>
    </div>

    <!-- Back Button -->
    <button class="back-button" onclick="goBack()">
        <i class="fas fa-arrow-left"></i> Back
    </button>

    <!-- Include JavaScript -->
    <script src="/static/splash-screen.js"></script>
    
    <script>
        // Authentication variables (same pattern as gridpage.js)
        let currentAacUserId = null;
        let firebaseIdToken = null;
        const AAC_USER_ID_SESSION_KEY = "currentAacUserId";
        const FIREBASE_TOKEN_SESSION_KEY = "firebaseIdToken";
        
        // Game state variables
        let currentGame = null;
        let gameState = {
            role: null, // 'ask' or 'answer'
            category: null, // 'person', 'place', 'thing'
            selectedItem: null, // The item being guessed (for 'answer' role)
            askedQuestions: [], // Array of {question, answer} objects
            questionCount: 0,
            guessCount: 0,
            previousGuesses: [], // Array of wrong guesses to exclude
            maxQuestions: 20,
            maxGuesses: 3,
            wakeWord: 'bravo', // Will be loaded from settings
            isListening: false,
            currentPhase: 'menu', // 'menu', 'role', 'category', 'ready', 'playing', 'guessing', 'finished'
            scanDelay: 3500, // Will be loaded from settings
            awaitingAnswerType: null // 'question' or 'guess'
        };

        // Speech recognition setup
        let recognition = null;
        let isRecognitionActive = false;
        
        // Scanning system
        let scanningSystem = {
            isScanning: false,
            currentContainer: null,
            currentIndex: 0,
            buttons: [],
            interval: null,
            restartDelay: 500
        };

        // Authenticated fetch function (same as other pages)
        async function authenticatedFetch(url, options = {}) {
            if (!firebaseIdToken || !currentAacUserId) {
                console.error("Authentication: Firebase ID Token or AAC User ID not found. Redirecting to login.");
                sessionStorage.clear();
                window.location.href = 'auth.html';
                throw new Error("Authentication required.");
            }

            const headers = {
                'Authorization': `Bearer ${firebaseIdToken}`,
                'X-User-ID': currentAacUserId,
                'Content-Type': 'application/json',
                ...options.headers
            };

            const response = await fetch(url, { ...options, headers });

            if (response.status === 401 || response.status === 403) {
                console.warn(`Authentication failed (${response.status}) for ${url}. Redirecting to login.`);
                sessionStorage.clear();
                window.location.href = 'auth.html';
                throw new Error("Authentication failed");
            }

            return response;
        }

        // Initialize user context (same pattern as other pages)
        async function initializeUserContext() {
            console.log('initializeUserContext: Starting initialization...');
            
            firebaseIdToken = sessionStorage.getItem(FIREBASE_TOKEN_SESSION_KEY);
            currentAacUserId = sessionStorage.getItem(AAC_USER_ID_SESSION_KEY);

            if (!firebaseIdToken || !currentAacUserId) {
                console.log("No Firebase ID Token or AAC User ID found in session. Redirecting to auth.html.");
                sessionStorage.clear();
                window.location.href = 'auth.html';
                return false;
            }
            
            console.log(`User context initialized. AAC User ID: ${currentAacUserId}`);
            return true;
        }

        // Initialize page when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Games page initializing...');
            initializeGamesPage();
        });

        // Add keyboard event listener for spacebar (same as gridpage)
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space' && scanningSystem.isScanning) {
                event.preventDefault();
                selectCurrentScannedButton();
            }
        });

        // Initialize the games page
        async function initializeGamesPage() {
            try {
                // Initialize authentication
                const userReady = await initializeUserContext();
                if (!userReady) {
                    return; // Redirection already handled
                }
                
                // Load user settings for wake word
                await loadUserSettings();
                
                // Initialize speech recognition
                initializeSpeechRecognition();
                
                // Hide splash screen
                hideSplashScreen();
                
            } catch (error) {
                console.error('Error initializing games page:', error);
                showError('Failed to initialize games. Please refresh the page.');
                hideSplashScreen();
            }
        }

        // Load user settings
        async function loadUserSettings() {
            try {
                const response = await authenticatedFetch('/api/settings');
                if (response.ok) {
                    const settings = await response.json();
                    gameState.wakeWord = (settings.wakeWordInterjection + ' ' + settings.wakeWordName).toLowerCase();
                    console.log('Wake word loaded:', gameState.wakeWord);
                    
                    // Load scan delay setting (same as gridpage)
                    if (settings && typeof settings.scanDelay === 'number' && !isNaN(settings.scanDelay)) {
                        gameState.scanDelay = Math.max(100, parseInt(settings.scanDelay));
                        console.log(`Games scan delay loaded: ${gameState.scanDelay}ms`);
                    } else {
                        gameState.scanDelay = 3500; // Default
                    }
                }
            } catch (error) {
                console.error('Error loading user settings:', error);
                // Use defaults
                gameState.wakeWord = 'hey bravo';
                gameState.scanDelay = 3500;
            }
        }

        // Initialize speech recognition
        function initializeSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                
                recognition.onstart = function() {
                    console.log('Speech recognition started');
                    isRecognitionActive = true;
                    showListening();
                };
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript.toLowerCase().trim();
                    console.log('Speech recognized:', transcript);
                    handleSpeechResult(transcript);
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    hideListening();
                    isRecognitionActive = false;
                    
                    // Auto-restart for certain phases
                    if (gameState.currentPhase === 'ready' || 
                        gameState.currentPhase === 'awaiting_wake_word' ||
                        gameState.currentPhase === 'awaiting_answer') {
                        setTimeout(() => {
                            if (gameState.currentPhase === 'ready' || 
                                gameState.currentPhase === 'awaiting_wake_word' ||
                                gameState.currentPhase === 'awaiting_answer') {
                                startListening();
                            }
                        }, 1500);
                    }
                };
                
                recognition.onend = function() {
                    console.log('Speech recognition ended');
                    hideListening();
                    isRecognitionActive = false;
                    
                    // Auto-restart for certain phases, but wait longer if an announcement is playing
                    if (gameState.currentPhase === 'ready' || 
                        gameState.currentPhase === 'awaiting_wake_word' ||
                        gameState.currentPhase === 'awaiting_answer') {
                        
                        // If an announcement is currently playing, wait longer to avoid interference
                        const delay = isAnnouncingNow ? 4000 : 1000;
                        console.log(`Recognition onend: Restarting in ${delay}ms (announcing: ${isAnnouncingNow})`);
                        
                        setTimeout(() => {
                            if (gameState.currentPhase === 'ready' || 
                                gameState.currentPhase === 'awaiting_wake_word' ||
                                gameState.currentPhase === 'awaiting_answer') {
                                startListening();
                            }
                        }, delay);
                    }
                };
            } else {
                console.warn('Speech recognition not supported in this browser');
            }
        }

        // Handle speech recognition results
        function handleSpeechResult(transcript) {
            hideListening();
            
            // Check for wake word during scanning ONLY in voice response phases
            if (scanningSystem.isScanning && 
                (gameState.currentPhase === 'playing' || gameState.currentPhase === 'guessing') &&
                (transcript.includes(gameState.wakeWord.replace(' ', '')) || 
                 transcript.includes(gameState.wakeWord))) {
                selectCurrentScannedButton();
                return;
            }
            
            if (gameState.currentPhase === 'ready') {
                // Waiting for "ready"
                if (transcript.includes('ready')) {
                    proceedAfterReady();
                } else {
                    // Announce waiting message - onend handler will restart listening after proper delay
                    announce("I'm waiting for you to say 'ready'");
                }
            } else if (gameState.currentPhase === 'awaiting_answer') {
                // Waiting for yes/no answer
                if (transcript.includes('yes')) {
                    handleAnswer('Yes');
                } else if (transcript.includes('no')) {
                    handleAnswer('No');
                } else {
                    announce("Please say 'yes' or 'no'");
                    // Restart listening after a delay
                    setTimeout(() => {
                        if (gameState.currentPhase === 'awaiting_answer') {
                            startListening();
                        }
                    }, 2000);
                }
            } else if (gameState.currentPhase === 'awaiting_wake_word') {
                // Waiting for wake word
                if (transcript.includes(gameState.wakeWord.replace(' ', '')) || 
                    transcript.includes(gameState.wakeWord)) {
                    handleWakeWord();
                } else {
                    // Keep listening for wake word silently
                    setTimeout(() => {
                        if (gameState.currentPhase === 'awaiting_wake_word') {
                            startListening();
                        }
                    }, 1000);
                }
            } else if (gameState.currentPhase === 'listening_for_intent') {
                // Waiting for "question" or "guess"
                if (transcript.includes('question')) {
                    handlePlayerIntent('question');
                } else if (transcript.includes('guess')) {
                    handlePlayerIntent('guess');
                } else {
                    announce("Do you have a question or guess?");
                    // Restart listening after a delay
                    setTimeout(() => {
                        if (gameState.currentPhase === 'listening_for_intent') {
                            startListening();
                        }
                    }, 2000);
                }
            } else if (gameState.currentPhase === 'listening_for_question') {
                // Listening for the actual question
                handlePlayerQuestion(transcript);
            } else if (gameState.currentPhase === 'listening_for_guess') {
                // Listening for the actual guess
                handlePlayerGuess(transcript);
            } else if (gameState.currentPhase === 'selecting_response') {
                // Ignore speech while selecting response options via scanning
                // Do nothing - let the user scan through options
                return;
            }
        }

        // Start listening for speech
        function startListening() {
            console.log(`LISTENING: startListening() called in phase: ${gameState.currentPhase}`);
            
            // Completely prevent listening during action selection and response selection phases
            if (gameState.currentPhase === 'action_selection' || gameState.currentPhase === 'selecting_response') {
                console.log(`LISTENING: Blocked during ${gameState.currentPhase} phase`);
                return;
            }
            
            if (recognition && !isRecognitionActive) {
                try {
                    recognition.start();
                } catch (error) {
                    console.error('Error starting speech recognition:', error);
                    // Retry after a short delay
                    setTimeout(() => {
                        if (!isRecognitionActive && 
                            (gameState.currentPhase === 'ready' || 
                             gameState.currentPhase === 'awaiting_wake_word' ||
                             gameState.currentPhase === 'awaiting_answer')) {
                            startListening();
                        }
                    }, 1000);
                }
            }
        }

        // Stop listening for speech
        function stopListening() {
            if (recognition && isRecognitionActive) {
                try {
                    recognition.stop();
                    isRecognitionActive = false;
                    hideListening();
                } catch (error) {
                    console.log('Recognition already stopped or error stopping:', error);
                }
            }
        }

        // Scanning System Functions
        function startScanning(containerId) {
            console.log(`SCANNING: Starting scan for container: ${containerId}`);
            
            // Stop any existing scanning first
            stopScanning();
            
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`SCANNING: Container ${containerId} not found`);
                return;
            }
            
            console.log(`SCANNING: Container found:`, container);
            console.log(`SCANNING: Container classes:`, container.className);
            console.log(`SCANNING: Container hidden?`, container.classList.contains('hidden'));
            
            scanningSystem.currentContainer = container;
            // Look for game-button classes (action buttons now use game-button class)
            scanningSystem.buttons = Array.from(container.querySelectorAll('.game-button'));
            scanningSystem.currentIndex = 0;
            scanningSystem.isScanning = true;
            
            console.log(`SCANNING: Found ${scanningSystem.buttons.length} buttons`);
            scanningSystem.buttons.forEach((btn, i) => {
                console.log(`SCANNING: Button ${i}: "${btn.textContent}" classes: ${btn.className}`);
            });
            console.log(`SCANNING: scanDelay is ${gameState.scanDelay}ms`);
            
            if (scanningSystem.buttons.length === 0) {
                console.error('SCANNING: No buttons found');
                return;
            }
            
            // Start scanning cycle
            scanNextButton();
        }

        function scanNextButton() {
            if (!scanningSystem.isScanning || scanningSystem.buttons.length === 0) return;
            
            console.log(`SCANNING: Index ${scanningSystem.currentIndex}, Delay: ${gameState.scanDelay}ms`);
            
            // Remove scanning class from all buttons
            scanningSystem.buttons.forEach(btn => {
                btn.classList.remove('scanning');
            });
            
            // Add scanning class to current button
            const currentButton = scanningSystem.buttons[scanningSystem.currentIndex];
            if (currentButton) {
                currentButton.classList.add('scanning');
                
                // Get button text for speech synthesis (like gridpage - use speechSynthesis, not announce)
                let buttonText = currentButton.textContent || currentButton.innerText || '';
                // Clean up the text (remove extra whitespace)
                buttonText = buttonText.trim().replace(/\s+/g, ' ');
                
                console.log(`SCANNING: Speaking "${buttonText}"`);
                
                // Use speechSynthesis for scanning (personal speaker/voice, like gridpage)
                try {
                    const utterance = new SpeechSynthesisUtterance(buttonText);
                    window.speechSynthesis.cancel();
                    window.speechSynthesis.speak(utterance);
                    console.log('SCANNING: Speech synthesis called successfully');
                } catch (e) {
                    console.error("Speech synthesis error:", e);
                }
            }
            
            // Move to next button
            scanningSystem.currentIndex = (scanningSystem.currentIndex + 1) % scanningSystem.buttons.length;
            
            // Schedule next scan using user's scan delay setting
            console.log(`SCANNING: Next scan in ${gameState.scanDelay}ms`);
            scanningSystem.interval = setTimeout(scanNextButton, gameState.scanDelay);
        }

        function stopScanning() {
            scanningSystem.isScanning = false;
            if (scanningSystem.interval) {
                clearTimeout(scanningSystem.interval);
                scanningSystem.interval = null;
            }
            
            // Remove scanning class from all buttons
            if (scanningSystem.buttons) {
                scanningSystem.buttons.forEach(btn => {
                    btn.classList.remove('scanning');
                });
            }
        }

        function selectCurrentScannedButton() {
            if (!scanningSystem.isScanning || scanningSystem.buttons.length === 0) return;
            
            // Get the currently highlighted button
            const currentButton = scanningSystem.buttons.find(btn => btn.classList.contains('scanning'));
            
            if (currentButton) {
                stopScanning();
                currentButton.click();
            }
        }

        // Show/hide listening indicator
        function showListening() {
            document.getElementById('listeningIndicator').classList.remove('hidden');
        }

        function hideListening() {
            document.getElementById('listeningIndicator').classList.add('hidden');
        }

        // Announcement queue and processing (same as gridpage.js)
        let announcementQueue = [];
        let isAnnouncingNow = false;

        // Base64 to ArrayBuffer conversion
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Play audio to device (simplified version of gridpage)
        async function playAudioToDevice(audioDataBuffer, sampleRate, announcementType) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(audioDataBuffer);
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                
                return new Promise((resolve, reject) => {
                    source.onended = resolve;
                    source.onerror = reject;
                    source.start(0);
                });
            } catch (error) {
                console.error('Error playing audio:', error);
                throw error;
            }
        }

        // Process announcement queue (same pattern as gridpage.js)
        async function processAnnouncementQueue() {
            if (isAnnouncingNow || announcementQueue.length === 0) {
                return;
            }

            isAnnouncingNow = true;
            const { textToAnnounce, announcementType, resolve, reject } = announcementQueue.shift();

            console.log(`ANNOUNCE QUEUE: Playing "${textToAnnounce.substring(0, 30)}..." (Type: ${announcementType})`);

            // Show speech bubble if enabled (same as gridpage.js)
            if (typeof showSplashScreen === 'function') {
                showSplashScreen(textToAnnounce);
            }

            // Stop speech recognition during announcements to prevent interference
            if (recognition && isRecognitionActive) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.log('Recognition already stopped');
                }
            }

            try {
                // Fetch audio data from server using authenticatedFetch (same as gridpage)
                const response = await authenticatedFetch(`/play-audio`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: textToAnnounce, routing_target: announcementType }),
                });

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => response.text());
                    throw new Error(`Failed to synthesize audio: ${response.status} - ${JSON.stringify(errorBody)}`);
                }

                const jsonResponse = await response.json();
                const audioData = jsonResponse.audio_data;
                const sampleRate = jsonResponse.sample_rate;

                if (!audioData) {
                    throw new Error("No audio data received from server.");
                }

                const audioDataArrayBuffer = base64ToArrayBuffer(audioData);
                await playAudioToDevice(audioDataArrayBuffer, sampleRate, announcementType);

                resolve(); // Resolve the promise for this announcement
            } catch (error) {
                console.error('Error in announcement:', error);
                reject(error);
            } finally {
                isAnnouncingNow = false;
                // Process next announcement in queue
                processAnnouncementQueue();
            }
        }

        // Announce text using same system as gridpage.js
        async function announce(textToAnnounce, announcementType = "system") {
            console.log(`ANNOUNCE: QUEUING "${textToAnnounce.substring(0, 30)}..." (Type: ${announcementType})`);
            
            return new Promise((resolve, reject) => {
                announcementQueue.push({
                    textToAnnounce,
                    announcementType,
                    resolve,
                    reject
                });

                // Trigger the queue processing
                processAnnouncementQueue();
            });
        }

        // Start 20 Questions game
        function startTwentyQuestions() {
            currentGame = '20_questions';
            gameState = {
                role: null,
                category: null,
                selectedItem: null,
                askedQuestions: [],
                questionCount: 0,
                guessCount: 0,
                maxQuestions: 20,
                maxGuesses: 3,
                previousGuesses: [],
                currentGuess: null,
                wakeWord: gameState.wakeWord,
                scanDelay: gameState.scanDelay || 3500, // Preserve or default scan delay
                isListening: false,
                currentPhase: 'role'
            };
            
            // Hide menu and show game
            document.getElementById('gameMenu').classList.add('hidden');
            document.getElementById('twentyQuestionsGame').classList.remove('hidden');
            
            // Show role selection
            document.getElementById('statusText').textContent = 'Choose how you want to play:';
            document.getElementById('roleSelection').classList.remove('hidden');
            
            announce("Let's play 20 questions!");
            
            // Start scanning for role selection (no listening - user taps/uses switch)
            setTimeout(() => {
                startScanning('roleSelection');
            }, 2000);
        }

        // Select game role
        function selectRole(role) {
            gameState.role = role;
            
            // Stop scanning when role is selected
            stopScanning();
            
            // Hide role selection
            document.getElementById('roleSelection').classList.add('hidden');
            
            if (role === 'ask') {
                // User will ask questions - skip category selection, go straight to ready
                gameState.currentPhase = 'ready';
                gameState.category = 'thing'; // Default to 'thing', LLM will ask "Is it a person?" etc.
                document.getElementById('statusText').textContent = 'Say "ready" when you have selected something for me to guess';
                announce('I will ask the questions, say "ready" when you have selected something for me to guess');
                
                // Start listening for "ready"
                setTimeout(() => {
                    startListening();
                }, 2000);
                
            } else {
                // User will answer questions - show category selection with scanning (no listening)
                gameState.currentPhase = 'category';
                document.getElementById('statusText').textContent = 'What type of thing are you thinking of?';
                
                // Announce that Player 2 will ask questions
                announce("Let's see if you can guess what I am thinking. Give me a moment to pick something");
                
                // Delay before showing category selection so announcement plays
                setTimeout(() => {
                    document.getElementById('categorySelection').classList.remove('hidden');
                    
                    // Start scanning for category selection (no listening - user taps/uses switch)
                    setTimeout(() => {
                        startScanning('categorySelection');
                    }, 500);
                }, 3500);
            }
        }

        // Select category
        function selectCategory(category) {
            gameState.category = category;
            
            // Stop scanning
            stopScanning();
            
            // Hide category selection
            document.getElementById('categorySelection').classList.add('hidden');
            
            if (gameState.role === 'ask') {
                // This path should not be reached since we skip category for 'ask' role
                // But just in case, handle it
                gameState.currentPhase = 'ready';
                document.getElementById('statusText').textContent = 'Say "ready" when you have selected your ' + category;
                announce('Say "ready" when you have selected your ' + category);
                
                // Start listening for "ready"
                setTimeout(() => {
                    startListening();
                }, 2000);
                
            } else {
                // User will answer questions - show P/P/T options
                gameState.currentPhase = 'selecting';
                loadGameOptions();
            }
        }

        // Proceed after user says "ready"
        async function proceedAfterReady() {
            gameState.currentPhase = 'playing';
            document.getElementById('statusText').textContent = 'Let me think of some questions...';
            
            // Generate first set of questions
            await loadQuestions();
        }

        // Load game options (person/place/thing choices)
        async function loadGameOptions() {
            showLoading();
            
            try {
                const requestPayload = {
                    game_type: '20_questions',
                    category: gameState.category,
                    request_different: false
                };
                
                console.log('Sending options request:', requestPayload);
                
                const response = await authenticatedFetch('/api/games/options', {
                    method: 'POST',
                    body: JSON.stringify(requestPayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API error response:', errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Game options loaded:', data);
                
                hideLoading();
                displayOptions(data.options, 'select');
                
                // Start scanning for selection (no listening - user taps/uses switch)
                setTimeout(() => {
                    startScanning('optionsSelection');
                }, 500);
                
            } catch (error) {
                console.error('Error loading game options:', error);
                hideLoading();
                showError('Failed to load options. Please try again.');
            }
        }

        // Load questions for the game
        async function loadQuestions() {
            showLoading();
            
            try {
                const requestPayload = {
                    game_type: '20_questions',
                    category: gameState.category,
                    asked_questions: gameState.askedQuestions,
                    question_count: gameState.questionCount,
                    exclude_options: gameState.currentOptions || []
                };
                
                console.log('Sending questions request:', requestPayload);
                
                const response = await authenticatedFetch('/api/games/questions', {
                    method: 'POST',
                    body: JSON.stringify(requestPayload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API error response:', errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Questions loaded:', data);
                
                hideLoading();
                displayOptions(data.questions, 'question');
                updateQuestionCounter();
                
            } catch (error) {
                console.error('Error loading questions:', error);
                hideLoading();
                showError('Failed to load questions. Please try again.');
            }
        }

        // Load guess options
        async function loadGuesses() {
            showLoading();
            
            try {
                const response = await authenticatedFetch('/api/games/guesses', {
                    method: 'POST',
                    body: JSON.stringify({
                        game_type: '20_questions',
                        category: gameState.category,
                        asked_questions: gameState.askedQuestions,
                        guess_count: gameState.guessCount,
                        previous_guesses: gameState.previousGuesses,
                        exclude_options: gameState.currentOptions || []
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Guesses loaded:', data);
                
                hideLoading();
                displayOptions(data.guesses, 'guess');
                
            } catch (error) {
                console.error('Error loading guesses:', error);
                hideLoading();
                showError('Failed to load guesses. Please try again.');
            }
        }

        // Display options (questions, guesses, or selections)
        function displayOptions(options, type) {
            // Store current options for exclusion when requesting different ones
            gameState.currentOptions = options;
            
            const container = document.getElementById('optionsSelection');
            container.innerHTML = '';
            container.classList.remove('hidden');
            
            // Add the main options
            options.forEach((option, index) => {
                const button = document.createElement('div');
                button.className = 'game-button';
                button.onclick = () => handleOptionClick(option, type);
                
                if (type === 'question') {
                    button.innerHTML = `<i class="fas fa-question"></i>${option}`;
                } else if (type === 'guess') {
                    button.innerHTML = `<i class="fas fa-lightbulb"></i>Is it ${option}?`;
                } else if (type === 'select') {
                    button.innerHTML = `<i class="fas fa-star"></i>${option}`;
                }
                
                container.appendChild(button);
            });
            
            // Add "Something Else" button
            const somethingElseButton = document.createElement('div');
            somethingElseButton.className = 'game-button';
            somethingElseButton.onclick = () => handleSomethingElse(type);
            somethingElseButton.innerHTML = `<i class="fas fa-sync-alt"></i>Something Else`;
            container.appendChild(somethingElseButton);
            
            // Add "Exit Game" button
            const exitButton = document.createElement('div');
            exitButton.className = 'game-button';
            exitButton.style.backgroundColor = '#dc2626';
            exitButton.style.color = 'white';
            exitButton.onclick = () => exitGame();
            exitButton.innerHTML = `<i class="fas fa-times"></i>Exit Game`;
            container.appendChild(exitButton);
            
            // Update status text based on type
            if (type === 'question') {
                document.getElementById('statusText').textContent = `Questions remaining: ${gameState.maxQuestions - gameState.questionCount}`;
            } else if (type === 'guess') {
                document.getElementById('statusText').textContent = `Guesses remaining: ${gameState.maxGuesses - gameState.guessCount}`;
            } else if (type === 'select') {
                document.getElementById('statusText').textContent = `Choose your ${gameState.category}:`;
            }
            
            // Start scanning after options are displayed (no listening - user should scan/select)
            setTimeout(() => {
                startScanning('optionsSelection');
            }, 500);
        }

        // Handle option click
        function handleOptionClick(option, type) {
            // Stop scanning when option is selected
            stopScanning();
            
            if (type === 'question') {
                askQuestion(option);
            } else if (type === 'guess') {
                makeGuessAttempt(option);
            } else if (type === 'select') {
                selectItem(option);
            }
        }

        // Handle "Something Else" button
        function handleSomethingElse(type) {
            // Stop current scanning
            stopScanning();
            
            if (type === 'question') {
                loadQuestions();
            } else if (type === 'guess') {
                loadGuesses();
            } else if (type === 'select') {
                // Request different options
                loadDifferentOptions();
            }
        }

        // Load different options for selection
        async function loadDifferentOptions() {
            showLoading();
            
            try {
                const response = await authenticatedFetch('/api/games/options', {
                    method: 'POST',
                    body: JSON.stringify({
                        game_type: '20_questions',
                        category: gameState.category,
                        request_different: true,
                        exclude_options: gameState.currentOptions || []
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Different options loaded:', data);
                
                hideLoading();
                displayOptions(data.options, 'select');
                
            } catch (error) {
                console.error('Error loading different options:', error);
                hideLoading();
                showError('Failed to load different options. Please try again.');
            }
        }

        // Select an item for the "you ask questions" mode
        function selectItem(item) {
            gameState.selectedItem = item;
            gameState.currentPhase = 'awaiting_wake_word';
            
            // Hide options
            document.getElementById('optionsSelection').classList.add('hidden');
            
            document.getElementById('statusText').textContent = `I'm ready. To ask a question or make a guess, start with "${gameState.wakeWord}".`;
            announce(`I'm ready. To ask a question or make a guess, start with ${gameState.wakeWord}.`);
            
            // Start listening for wake word
            setTimeout(() => {
                startListening();
            }, 3000);
        }

        // Handle wake word detected
        function handleWakeWord() {
            gameState.currentPhase = 'listening_for_intent';
            announce("I'm listening. Do you have a question or guess?");
            
            // Wait for the announcement to finish playing, then start listening for intent
            setTimeout(() => {
                if (gameState.currentPhase === 'listening_for_intent') {
                    startListening();
                }
            }, 4000); // Increased to 4 seconds to give time for TTS and user response
        }

        // Handle player intent (question or guess)
        function handlePlayerIntent(intent) {
            if (intent === 'question') {
                gameState.currentPhase = 'listening_for_question';
                announce("Ready for your question");
                
                setTimeout(() => {
                    startListening();
                }, 2000);
                
            } else if (intent === 'guess') {
                gameState.currentPhase = 'listening_for_guess';
                announce("Ready for your guess");
                
                setTimeout(() => {
                    startListening();
                }, 2000);
            }
        }

        // Handle player question
        async function handlePlayerQuestion(question) {
            // This function should ONLY be called on the 'answer' role path (You Guess)
            // On the 'ask' role path (I Guess), questions are handled via loadQuestions + askQuestion
            if (gameState.role !== 'answer') {
                console.error('handlePlayerQuestion called on wrong role:', gameState.role);
                return;
            }
            
            gameState.questionCount++;
            updateQuestionCounter();
            gameState.currentQuestion = question; // Store the question
            
            // Announce the question back to Player 1
            announce(`Ok. Your question is ${question}. Give me a moment to respond`);
            
            // Load response options after small delay (instead of calling /api/games/answer)
            setTimeout(() => {
                loadResponseOptions('question_response');
            }, 2000);
        }

        // Handle player guess
        function handlePlayerGuess(guess) {
            // This function should ONLY be called on the 'answer' role path (You Guess)
            // On the 'ask' role path (I Guess), guesses are handled via loadGuesses + makeGuessAttempt
            if (gameState.role !== 'answer') {
                console.error('handlePlayerGuess called on wrong role:', gameState.role);
                return;
            }
            
            gameState.guessCount++;
            gameState.currentGuess = guess; // Store the guess
            
            // Announce the guess
            announce(`Ok. They guessed ${guess}. Give me a moment to respond`);
            
            // Load response options (both correct and incorrect options) after small delay
            setTimeout(() => {
                loadResponseOptions('guess_response');
            }, 2000);
        }

        // Ask a question (user asking mode)
        function askQuestion(question) {
            gameState.questionCount++;
            gameState.currentPhase = 'awaiting_answer';
            gameState.awaitingAnswerType = 'question';
            gameState.currentQuestion = question; // Store the question for history/LLM context
            
            // Hide options
            document.getElementById('optionsSelection').classList.add('hidden');
            
            // Announce the question
            announce(question);
            
            // Wait for first announcement to finish, then announce the instruction
            setTimeout(() => {
                announce('Say yes or no to answer the question');
                
                // Start listening for yes/no after the instruction announcement
                setTimeout(() => {
                    startListening();
                }, 3000);
            }, 3000);
        }

        // Handle yes/no answer
        function handleAnswer(answer) {
            // Stop listening since we got an answer
            stopListening();

            // If the last prompt was a guess, resolve the guess result and stop here
            if (gameState.awaitingAnswerType === 'guess') {
                const isCorrect = answer.toLowerCase() === 'yes';
                gameState.awaitingAnswerType = null;
                handleGuessResult(isCorrect);
                return;
            }
            
            // Add to question history
            const lastQuestion = gameState.askedQuestions.length > 0 ? 
                gameState.askedQuestions[gameState.askedQuestions.length - 1].question : 'Unknown';
            
            // Find the current question from the last asked
            // We need to store the current question when it's asked
            if (!gameState.currentQuestion) {
                gameState.currentQuestion = 'Question';
            }
            
            gameState.askedQuestions.push({
                question: gameState.currentQuestion,
                answer: answer
            });

            gameState.awaitingAnswerType = null;
            
            updateQuestionHistory();
            updateQuestionCounter();
            
            // Show action buttons or continue based on question count
            if (gameState.questionCount >= gameState.maxQuestions) {
                // Maximum questions reached, must guess
                loadGuesses();
            } else {
                // Show action buttons
                showActionButtons();
            }
        }

        // Store current question when asking
        function storeCurrentQuestion(question) {
            gameState.currentQuestion = question;
        }

        // Load response options for Player 1 to choose their response
        async function loadResponseOptions(responseType) {
            // Stop any active listening immediately and set proper phase
            stopListening();
            hideListening();
            gameState.currentPhase = 'response_selection';
            
            // Show loading state
            document.getElementById('loadingState').classList.remove('hidden');
            document.getElementById('responseOptions').classList.add('hidden');
            
            try {
                // Prepare request data
                const requestData = {
                    game_type: "20_questions",
                    response_type: responseType,
                    category: gameState.category,
                    selected_item: gameState.selectedItem,
                    player_question_or_guess: responseType === 'question_response' ? gameState.currentQuestion : gameState.currentGuess,
                    questions_remaining: gameState.maxQuestions - gameState.questionCount,
                    guesses_remaining: gameState.maxGuesses - gameState.guessCount,
                    questions_asked: gameState.questionCount,
                    guesses_made: gameState.guessCount
                };
                
                console.log('Loading response options for:', responseType);
                
                const response = await authenticatedFetch('/api/games/response-options', {
                    method: 'POST',
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load response options');
                }
                
                // Hide loading
                document.getElementById('loadingState').classList.add('hidden');
                
                // Store response type for later
                gameState.currentResponseType = responseType;
                gameState.responseOptions = data.response_options;
                
                console.log('Response options loaded:', data.response_options);
                
                // Display response options
                displayResponseOptions(data.response_options);
                
            } catch (error) {
                console.error('Error loading response options:', error);
                document.getElementById('loadingState').classList.add('hidden');
                document.getElementById('errorState').classList.remove('hidden');
                document.getElementById('errorMessage').textContent = 'Failed to generate response options. Try again.';
                
                // Retry after delay
                setTimeout(() => {
                    document.getElementById('errorState').classList.add('hidden');
                    loadResponseOptions(responseType);
                }, 2000);
            }
        }

        // Display response options in the grid
        function displayResponseOptions(options) {
            const container = document.getElementById('responseOptions');
            container.innerHTML = '';
            
            options.forEach((option, index) => {
                const button = document.createElement('div');
                button.className = 'game-button';
                // Store both answer_type in data attribute for retrieval
                if (option.answer_type) {
                    button.setAttribute('data-answer-type', option.answer_type);
                }
                // Handle both object format {text, answer_type} and string format
                const displayText = option.text || option;
                button.textContent = displayText;
                button.onclick = () => selectResponseOption(option, index);
                container.appendChild(button);
            });
            
            container.classList.remove('hidden');
            
            // Start scanning for response selection
            setTimeout(() => {
                startScanning('responseOptions');
            }, 500);
        }

        // Handle selection of a response option
        function selectResponseOption(selectedOption, index) {
            // Stop scanning
            stopScanning();
            
            // Hide response options
            document.getElementById('responseOptions').classList.add('hidden');
            
            // Extract response text and answer type
            let responseText, answerType;
            if (typeof selectedOption === 'object' && selectedOption.text) {
                responseText = selectedOption.text;
                answerType = selectedOption.answer_type;
            } else if (typeof selectedOption === 'string') {
                responseText = selectedOption;
                // Try to get from button's data attribute
                const buttons = document.querySelectorAll('#responseOptions .game-button');
                if (buttons[index]) {
                    answerType = buttons[index].getAttribute('data-answer-type');
                }
            }
            
            console.log('Selected:', responseText, 'Answer type:', answerType);
            
            // Store selection
            gameState.selectedResponse = responseText;
            gameState.selectedAnswerType = answerType;
            
            // Get remaining counts
            const questionsRemaining = gameState.maxQuestions - gameState.questionCount;
            const guessesRemaining = gameState.maxGuesses - gameState.guessCount;
            
            // Build announcement
            let announcement = responseText;
            
            // Handle based on response type
            if (gameState.currentResponseType === 'question_response') {
                // Question answer response
                announcement += `. You have ${questionsRemaining} question${questionsRemaining !== 1 ? 's' : ''} left.`;
                announce(announcement);
                
                setTimeout(() => {
                    // After responding to Player 2's question, listen for next question or guess
                    // Player 2 will either ask another question or make a guess
                    gameState.currentPhase = 'awaiting_wake_word';
                    hideListening();
                    document.getElementById('statusText').textContent = 'Listening for next question or guess...';
                    announce(`To ask another question or make a guess, start with ${gameState.wakeWord}.`);
                    showListening();
                    startListening();
                }, 3500);
                
            } else if (gameState.currentResponseType === 'guess_response') {
                // Guess response
                if (answerType === 'correct') {
                    // Guess was correct - Player 2 wins
                    announce(responseText);
                    setTimeout(() => {
                        announce(`You successfully guessed it! It was ${gameState.selectedItem}!`);
                        setTimeout(() => {
                            goBackToMenu();
                        }, 3000);
                    }, 2000);
                } else {
                    // Guess was incorrect
                    // Add to previous guesses
                    if (gameState.currentGuess) {
                        if (!gameState.previousGuesses) {
                            gameState.previousGuesses = [];
                        }
                        if (!gameState.previousGuesses.includes(gameState.currentGuess)) {
                            gameState.previousGuesses.push(gameState.currentGuess);
                        }
                    }
                    
                    if (guessesRemaining > 1) {
                        // More guesses available - continue with Player 2 asking questions or guessing
                        announcement += `. ${guessesRemaining - 1} guess${guessesRemaining !== 2 ? 'es' : ''} left.`;
                        announce(announcement);
                        setTimeout(() => {
                            // After incorrect guess, listen for Player 2's next question or guess
                            gameState.currentPhase = 'awaiting_wake_word';
                            hideListening();
                            document.getElementById('statusText').textContent = 'Listening for next question or guess...';
                            announce(`To ask another question or make a guess, start with ${gameState.wakeWord}.`);
                            showListening();
                            startListening();
                        }, 3500);
                    } else {
                        // No more guesses - Player 1 wins
                        announce(responseText);
                        setTimeout(() => {
                            announce(`You ran out of guesses. The answer was ${gameState.selectedItem}. Great game!`);
                            setTimeout(() => {
                                goBackToMenu();
                            }, 3000);
                        }, 2000);
                    }
                }
            }
        }

        // Show action buttons
        function showActionButtons() {
            // Ensure listening is stopped before showing action buttons
            stopListening();
            hideListening();
            
            // Set phase to action_selection to prevent wake word detection during scanning
            gameState.currentPhase = 'action_selection';
            
            document.getElementById('actionButtons').classList.remove('hidden');
            document.getElementById('statusText').textContent = 'What would you like to do next?';
            
            // Start scanning for action buttons (no listening - user taps/uses switch)
            setTimeout(() => {
                startScanning('actionButtons');
            }, 500);
        }

        // Ask another question
        function askAnother() {
            document.getElementById('actionButtons').classList.add('hidden');
            gameState.currentPhase = 'playing';
            loadQuestions();
        }

        // Make a guess
        function makeGuess() {
            document.getElementById('actionButtons').classList.add('hidden');
            gameState.currentPhase = 'guessing';
            loadGuesses();
        }

        // Make a guess attempt
        function makeGuessAttempt(guess) {
            gameState.guessCount++;
            gameState.currentGuess = guess; // Store current guess
            
            // Hide options
            document.getElementById('optionsSelection').classList.add('hidden');
            
            // Announce the guess as a proper question
            announce(`Is it ${guess}?`);
            
            if (gameState.role === 'answer') {
                gameState.currentPhase = 'awaiting_result';
                // Load response options after announcement (both correct and incorrect options)
                setTimeout(() => {
                    loadResponseOptions('guess_response');
                }, 3500);
            } else {
                gameState.currentPhase = 'awaiting_answer';
                gameState.awaitingAnswerType = 'guess';
                // Ask Player 2 to answer and listen for yes/no
                setTimeout(() => {
                    announce('Say yes or no to answer the question');
                    setTimeout(() => {
                        startListening();
                    }, 3000);
                }, 3000);
            }
        }

        // Handle guess result
        function handleGuessResult(isCorrect) {
            if (isCorrect) {
                announce("Great game! Thanks for playing!");
                setTimeout(() => {
                    goBackToMenu();
                }, 3000);
            } else {
                // Add wrong guess to previousGuesses to avoid repeating it
                if (gameState.currentGuess) {
                    if (!gameState.previousGuesses) {
                        gameState.previousGuesses = [];
                    }
                    if (!gameState.previousGuesses.includes(gameState.currentGuess)) {
                        gameState.previousGuesses.push(gameState.currentGuess);
                        console.log(`Added wrong guess to previousGuesses: ${gameState.currentGuess}`);
                        console.log(`Previous guesses now: ${JSON.stringify(gameState.previousGuesses)}`);
                    }
                }
                
                if (gameState.guessCount >= gameState.maxGuesses) {
                    announce("That was tough! I hope I do better next time!");
                    setTimeout(() => {
                        goBackToMenu();
                    }, 3000);
                } else {
                    // Stop scanning and show action buttons
                    stopScanning();
                    
                    // Show action buttons for another question or guess
                    const actionButtons = document.getElementById('actionButtons');
                    if (actionButtons) {
                        actionButtons.classList.remove('hidden');
                    }
                    
                    announce("Darn. Give me a moment to pick another question or guess.");
                    
                    // Update phase and prepare for scanning
                    gameState.currentPhase = 'action_selection';
                    
                    // Start scanning for action selection
                    setTimeout(() => {
                        startScanning('actionButtons');
                    }, 3500);
                }
            }
        }

        // Update question counter
        function updateQuestionCounter() {
            const counter = document.getElementById('gameCounter');
            if (gameState.role === 'ask') {
                counter.textContent = `Questions: ${gameState.questionCount}/${gameState.maxQuestions}`;
            } else {
                counter.textContent = `Questions: ${gameState.questionCount} | Guesses: ${gameState.guessCount}/${gameState.maxGuesses}`;
            }
        }

        // Update question history display
        function updateQuestionHistory() {
            const historyContainer = document.getElementById('questionHistory');
            const qaList = document.getElementById('qaList');
            
            if (gameState.askedQuestions.length > 0) {
                historyContainer.classList.remove('hidden');
                
                qaList.innerHTML = '';
                // Show most recent questions first by iterating in reverse
                for (let i = gameState.askedQuestions.length - 1; i >= 0; i--) {
                    const qa = gameState.askedQuestions[i];
                    const item = document.createElement('div');
                    item.className = 'qa-item';
                    item.innerHTML = `
                        <div class="qa-question">Q: ${qa.question}</div>
                        <div class="qa-answer">A: ${qa.answer}</div>
                    `;
                    qaList.appendChild(item);
                }
            }
        }

        // New game
        function newGame() {
            // Stop scanning and speech recognition
            stopScanning();
            if (recognition && isRecognitionActive) {
                recognition.stop();
            }
            
            // Reset game state but stay in game view
            gameState = {
                role: null,
                category: null,
                selectedItem: null,
                askedQuestions: [],
                questionCount: 0,
                guessCount: 0,
                maxQuestions: 20,
                maxGuesses: 3,
                wakeWord: gameState.wakeWord,
                isListening: false,
                currentPhase: 'role'
            };
            
            // Hide all game sections
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('optionsSelection').classList.add('hidden');
            document.getElementById('questionHistory').classList.add('hidden');
            document.getElementById('actionButtons').classList.add('hidden');
            document.getElementById('listeningIndicator').classList.add('hidden');
            document.getElementById('loadingState').classList.add('hidden');
            document.getElementById('errorState').classList.add('hidden');
            
            // Show role selection
            document.getElementById('statusText').textContent = 'Choose how you want to play:';
            document.getElementById('roleSelection').classList.remove('hidden');
            document.getElementById('gameCounter').textContent = '';
            
            announce("Let's play another round of 20 questions!");
            
            // Start scanning for role selection (no listening - user taps/uses switch)
            setTimeout(() => {
                startScanning('roleSelection');
            }, 2000);
        }

        // Exit game
        function exitGame() {
            goBackToMenu();
        }

        // Go back to main menu
        function goBackToMenu() {
            // Reset everything
            currentGame = null;
            gameState.currentPhase = 'menu';
            
            // Stop scanning
            stopScanning();
            
            // Stop any ongoing speech recognition
            if (recognition && isRecognitionActive) {
                recognition.stop();
            }
            
            // Cancel speech synthesis
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
            
            // Hide game view and show menu
            document.getElementById('twentyQuestionsGame').classList.add('hidden');
            document.getElementById('gameMenu').classList.remove('hidden');
            
            // Reset all game sections
            document.getElementById('roleSelection').classList.add('hidden');
            document.getElementById('categorySelection').classList.add('hidden');
            document.getElementById('optionsSelection').classList.add('hidden');
            document.getElementById('questionHistory').classList.add('hidden');
            document.getElementById('actionButtons').classList.add('hidden');
            document.getElementById('listeningIndicator').classList.add('hidden');
            document.getElementById('loadingState').classList.add('hidden');
            document.getElementById('errorState').classList.add('hidden');
        }

        // Show/hide loading state
        function showLoading() {
            document.getElementById('loadingState').classList.remove('hidden');
            document.getElementById('optionsSelection').classList.add('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingState').classList.add('hidden');
        }

        // Show error
        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorState').classList.remove('hidden');
            
            // Hide error after 5 seconds
            setTimeout(() => {
                document.getElementById('errorState').classList.add('hidden');
            }, 5000);
        }

        // Go back to previous page
        function goBack() {
            // Check if there's a referrer or previous page in history
            if (document.referrer && document.referrer.includes(window.location.hostname)) {
                window.history.back();
            } else {
                window.location.href = 'gridpage.html';
            }
        }

        // Hide splash screen
        function hideSplashScreen() {
            const splashScreen = document.getElementById('splashScreen');
            if (splashScreen) {
                splashScreen.style.display = 'none';
            }
            
            // Also check for splash screen managed by splash-screen.js
            if (window.splashScreen && window.splashScreen.hide) {
                window.splashScreen.hide();
            }
        }
    </script>
</body>
</html>